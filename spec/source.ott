
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar rvar, XX {{ tex X }}, YY {{ tex Y }} ::=

metavar typvar, X {{ tex \alpha }}, Y {{ tex \beta }} ::=

metavar var, x, y, f, D , R {{ tex \mathsf{R}  }}, TT {{ tex T }}, l, super {{ tex \mathsf{super} }}, self {{ tex \mathsf{self} }} ::=

indexvar i, j, k, n, m ::=

grammar

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SEDEL Syntax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Types

AA {{ tex \mathcal{A} }}, BB {{ tex \mathcal{B} }}, CT {{ tex \mathcal{C} }}  :: 'AA_' ::=
  | Top                           :: :: top
  | nat                           :: :: int
  | pri                           :: :: pri
  | AA -> BB                      :: :: arr
  | AA & BB                       :: :: and
  | X                             :: :: tvar
  | \ X ** AA  . BB               :: :: forall {{ tex \forall ( [[X]] [[**]] [[AA]] ) .\,[[BB]] }}
  | { l : AA }                    :: :: rcd
  | Trait [ AA , BB ]             :: :: trait
  | Trait [ BB ]                  :: :: trait2
  | { l1 : AA1 , ... , ln : AAn } :: :: rcd2
  | AA1 & ... & AAn               :: :: and2
  | bool                          :: :: bool
  | char                          :: :: char
  | string                        :: :: string
  | [ AA / X ] BB                 :: :: subst
  | ( AA )                        :: :: paren


%% Programs

pgm :: 'pgm_' ::=
  | E             :: :: expr
  | decl ; pgm    :: :: decl
  | [ AA / TT ] pgm :: :: subst


%% Declarations

decl :: 'decl_' ::=
  | def f ( x : AA ) : BB = E :: :: termDecl
  | typ TT = AA               :: :: typeDecl


%% Expressions

E {{ tex \mathcal{T} }}  :: 'E_' ::=
  | Top                                                                     :: :: top
  | x                                                                       :: :: var
  | ii                                                                      :: :: lit
  | BL                                                                      :: :: bool
  | \ x . E                                                                 :: :: lam
  | E1 E2                                                                   :: :: app
  | E1 ,, E2                                                                :: :: merge
  | \ X ** AA  . E                                                          :: :: blam {{ tex \Lambda ( [[X]] [[**]] [[AA]] ) .\,[[E]] }}
  | E AA                                                                    :: :: tapp
  | { l = E }                                                               :: :: rcd
  | E . l                                                                   :: :: proj
  | letrec x : AA = E1 in E2                                                :: :: letrec
  | new [ AA ] ( </ Ei // i /> )                                            :: :: new
  | E : AA                                                                  :: :: anno
  | E -- { l : AA }                                                         :: :: rem
  | trait [ self : BB ] inherits </ Ei // i /> { </ lj = Ej' // j /> } : AA :: :: trait
  | if E1 then E2 else E3                                                   :: :: if
  | E1 + E2                                                                 :: :: add
  | E1 - E2                                                                 :: :: sub
  | E1 * E2                                                                 :: :: mult
  | E1 / E2                                                                 :: :: div
  | E1 == E2                                                                :: :: eq
  | E1 /= E2                                                                :: :: neq
  | E1 < E2                                                                 :: :: lt
  | E1 > E2                                                                 :: :: gt
  | E1 ^ E2                                                                 :: :: lift {{ tex [[E1]] \ \textasciicircum \ [[E2]] }}
  | { l1 = E1 , ... , ln = En }                                             :: :: rcd2
  | { l1 = E1 } ,, ... ,, { ln = En }                                       :: :: rcd3
  | ( E )                                                                   :: :: paren


%% Contexts

SG {{ tex \Gamma }} :: 'SG_' ::=
  | empty                                     :: :: empty
  | SG , x : AA                               :: :: cons1

SD {{ tex \Delta }} :: 'SD_' ::=
  | empty                                     :: :: empty
  | SD , X ** AA                              :: :: cons2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fi+ Syntax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Types

sty, A, B, C, t :: 'sty_' ::=
  | nat          :: :: nat
  | pri          :: :: pri
  | bool          :: :: bool
  | Top          :: :: top
  | X            :: :: tvar
  | XX            :: :: rvar
  | A -> B       :: :: arrow
  | A & B        :: :: and
  | A | B        :: :: union
  | A * B  :: :: prod
  | A1 & ... & An               :: :: and2
  | \ X ** A . B :: :: all {{ tex \forall ( [[X]] [[**]] [[A]] ) .\,[[B]] }}
  | \ X . A        :: :: forall   {{ tex \forall [[X]].\,[[A]] }}
  | mu XX . A     :: :: recur   {{ tex \mu [[XX]] .\ [[A]] }}
  | { l : A }    :: :: rcd
  | { l1 : A1 , ... , ln : An } :: :: rcd2
  | ( A )        :: :: paren
  | [ B / X ] A  :: :: subst
  | p ( A )      :: :: pa
  | pq ( A )      :: :: pa2
  | fs -> A ::  :: lst
  | N ::  :: n  {{ tex \mathsf{I} }}
  | S ::  :: s  {{ tex \mathsf{S} }}
  | string ::  :: ss   {{ tex \mathsf{String} }}
  | | AA | :: :: trans
  | A =/ B :: :: lup {{ tex [[A]] \sqcup [[B]] }}


%% Expressions

sexp, ee {{ tex E }}, vv {{ tex v }} :: 'sexp_' ::=
  | x              :: :: var
  | Top            :: :: top
  | ii              :: :: lit
  | \ x . ee       :: :: abs  {{ tex [[\]][[x]].\,[[ee]] }}
  | \ x : A . ee       :: :: abs3  {{ tex [[\]][[x]] : [[A]] .\,[[ee]] }}
  | lam x . ee       :: :: abs2  {{ tex \\ \lambda  [[x]].\,[[ee]] }}
  | ee1 ee2        :: :: app
  | ee1 ,, ee2     :: :: merge
  | ee1 ,, ... ,, een ::  :: merge2
  | \ X ** A . ee  :: :: tabs {{ tex \Lambda ( [[X]] [[**]] [[A]] ) .\,[[ee]] }}
  | ee A           :: :: tapp
  | ee : A         :: :: anno
  | { l = ee }     :: :: rcd
  | { l1 = ee1 , ... , ln = een }     :: :: rcdn
  | ee . l         :: :: proj
  | [ee2 / x ] ee1 :: :: subst
  | [ A / X ] ee   :: :: tsubst
  | CC { ee }      :: :: appctx
  | letrec x : A = ee1 in ee2 :: :: letrec
  | let x = ee1 in ee2  :: :: let
  | 1 ::  :: one   {{ tex 1  }}
  | 2 ::  :: two   {{ tex 2  }}
  | true ::  :: true   {{ tex \mathsf{true}  }}
  | ss :: :: ss        {{ tex ``c" }}
  | ( ee ) :: :: parens


%% Value contexts

GG {{ tex \Gamma }} :: 'sctx_'     ::=
  | empty          ::   :: empty
  | GG , x : A     ::   :: cons
  | | SG |   :: :: trans


%% Type contexts

DD {{ tex \Delta }} :: 'stctx'  ::=
  | empty       :: ::  empty
  | DD , X ** A :: :: cons
  | | SD |   :: :: trans
  | [ A / X ] DD :: :: subst
  | X ** A :: :: con1


SS {{ tex \Sigma }} :: 'rtctx'  ::=
  | empty       :: ::  empty
  | SS , XX <: YY :: :: cons



%% Expression contexts

CC {{ tex \mathcal{C} }} :: 'C_' ::=
  | __            :: :: empty
  | \ x . CC      :: :: lam {{ tex [[\]][[x]].\,[[CC]] }}
  | \ X ** A . CC :: :: tabs {{ tex \Lambda (  [[X]]  [[**]] [[A]] ) .\, [[CC]] }}
  | CC A          :: :: tapp
  | CC ee         :: :: appL
  | ee CC         :: :: appR
  | CC ,, ee      :: :: mergeL
  | ee ,, CC      :: :: mergeR
  | CC : A        :: :: anno
  | { l = CC }    :: :: rcd
  | CC . l        :: :: proj
  | ( CC )        :: :: paren


%% Modes

dir {{ tex \Leftrightarrow }} :: '' ::=
   | =>             ::   :: Inf
   | <=             ::   :: Chk


%% Type substitution

p {{ tex \rho }} :: 'p_' ::=
  | emp           :: :: empty   {{ tex \emptyset }}
  | p [ X -> A  ] :: :: one   {{ tex [[p]] [  [[X]] \mapsto  [[A]] ] }}


%% Type substitution

pq {{ tex \rho }} :: 'pq_' ::=
  | emp           :: :: empty   {{ tex \emptyset }}
  | pq [ X -> R  ] :: :: one   {{ tex [[pq]] [  [[X]] \mapsto  [[R]] ] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% System F Syntax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%% Types

ty, T {{ tex \tau }} :: 'ty_' ::=
  | nat            :: :: nat
  | pri            :: :: pri
  | Unit           :: :: unit
  | X              :: :: var
  | T1 -> T2       :: :: arrow
  | T1 * T2        :: :: prod
  % | { l : T }      :: :: rcd
  | \ X . T        :: :: forall   {{ tex \forall [[X]].\,[[T]] }}
  | ( T )          :: :: paren
  | [ T2 / X ] T1  :: :: subst
  | bool                          :: :: bool
  | char                          :: :: char
  | | A |          :: :: erase


%% Terms

exp, e, v :: 'exp_'     ::=
  | x             :: :: var
  | unit          :: :: unit
  | ii             :: :: lit
  | \ x . e       :: :: abs {{ tex [[\]][[x]].\,[[e]] }}
  | e1 e2         :: :: app
  | < e1 , e2 >   :: :: pair
  | c e           :: :: capp
  | { l = e }     :: :: rcd
  | e . l           :: :: proj
  | \ X . e       :: :: tabs  {{ tex \Lambda [[X]].\,[[e]] }}
  | e T           :: :: tapp
  | [ e2 / x ] e1 :: :: subst
  | [ T / X ] e   :: :: tsubst
  | ( e )         :: :: paren
  | cc { e }      :: :: appctx
  | g ( e )       :: :: gsubst
  | p ( e )       :: :: psubst
  | 1 ::  :: one   {{ tex 1  }}
  | 2 ::  :: two   {{ tex 2  }}
  | EE . e   :: :: Ctx {{ tex [[EE]] [ [[e]] ] }}
  | [ A , e ] :: :: co {{ tex \llbracket [[A]] \rrbracket_{[[e]]} }}


EE :: 'EE_' ::= {{ tex \mathcal{E} }}
  | __            :: :: empty
  | EE T          :: :: tapp
  | EE e         :: :: appL
  | v EE         :: :: appR
  | < EE , e >     :: :: pairL
  | < v , EE >      :: :: pairR
  | c EE         :: :: co
  | ( EE )        :: :: paren


%% Coercions

co, c :: 'co_' ::=   {{ com coercion }}
  | id          :: :: id
  | c1 o c2     :: :: trans {{ tex [[c1]] \circ [[c2]] }}
  | top         :: :: top
  | c1 -> c2    :: :: arr
  | \ c :: :: forall {{ tex [[c]]_{\forall} }}
  | < c1 , c2 > :: :: pair
  | pp1          :: :: proj1
  | pp2          :: :: proj2
  | distArr     :: :: distArr
  | distRcd l   :: :: distRcd {{ tex \mathsf{dist}_{ \{ [[l]] \} } }}
  % | { l : c }   :: :: rcd
  | topArr      :: :: topArr
  % | < l >       :: :: topRcd {{ tex \mathsf{top}_{ \{ [[l]] \} } }}
  | ( c )       :: :: paren
  | < fs >1     :: :: tran1  {{ tex \llbracket [[fs]] \rrbracket_{\top} }}
  | < fs >2     :: :: tran2  {{ tex \llbracket [[fs]] \rrbracket_{\&} }}



%% Value contexts

gg {{ tex \Psi }} :: 'ctx_'     ::=
  | empty      ::   :: empty
  | gg , x : T ::   :: cons
  | | GG |     :: S :: trans


%% Type contexts

dd {{ tex \Phi }} :: 'tctx_'  ::=
  | empty  ::   ::  empty
  | dd , X ::   :: cons
  | | DD | :: S :: trans


%% Term contexts

cc {{ tex \mathcal{D} }} :: 'cc_' ::=
  | __         ::   :: empty
  | \ x . cc   ::   :: lam {{ tex [[\]][[x]].\,[[cc]] }}
  | \ X . cc   ::   :: tabs {{ tex \Lambda [[X]] .\, [[cc]] }}
  | cc T       ::   :: tapp
  | cc e       ::   :: appL
  | e cc       ::   :: appR
  | < cc , e > ::   :: pairL
  | < e , cc > ::   :: pairR
  | c cc       ::   :: co
  | { l = cc } ::   :: rcd
  | cc . l     ::   :: proj
  | ( cc )     :: S :: paren



%% Value substitution

g {{ tex \gamma}} :: 'g_' ::=
  | emp          :: :: empty  {{ tex \emptyset }}
  | g [ x -> v ] :: :: one  {{ tex [[g]] [  [[x]] \mapsto [[v]] ] }}


%% Value substitution

ls, fs {{ tex \mathcal{L} }} :: 'ls_' ::=
  | []         :: :: empty
  | ls , A     :: :: cons1
  | A , ls     :: :: cons2
  | ls , { l } :: :: con3
  | { l } , ls :: :: cons4
  | ( ls )     :: :: paren




terminals :: 'terminals_' ::=
    | ii      :: :: Arith      {{ tex i }}
    | BL      :: :: Bool       {{ tex \mathbb{B} }}
    | \       :: :: lambda     {{ tex \lambda }}
    | -->     :: :: red        {{ tex \longrightarrow }}
    | -->>    :: :: red2    {{ tex \longrightarrow^{*} }}
    | ->      :: :: arrow      {{ tex \rightarrow }}
    | |-      :: :: turnstile  {{ tex \vdash }}
    | ||-      :: :: turnstile2  {{ tex \vdash }}
    | pp1      :: :: proj1 {{ tex \pi_1 }}
    | pp2      :: :: proj2 {{ tex \pi_2 }}
    | <       :: :: lbr  {{ tex \langle }}
    | >       :: :: rbr  {{ tex \rangle }}
    | *       :: :: prod {{ tex \times }}
    | dot     :: :: dot  {{ tex [ \cdot ] }}
    | empty   :: :: empty {{ tex \cdot }}
    | |-      :: :: dash  {{ tex \vdash }}
    | elt     :: :: elt       {{ tex \in }}
    | tri     :: :: tri       {{ tex \triangleright }}
    | id      :: :: id  {{ tex \mathsf{id} }}
    | Top     :: :: Top  {{ tex \top }}
    | nat     :: :: nat  {{ tex \mathsf{Int} }}
    | pri     :: :: pri  {{ tex \rho }}
    | char    :: :: char  {{ tex \mathsf{Char} }}
    | bool    :: :: bool  {{ tex \mathsf{Bool} }}
    % | ,,      :: :: Merge  {{ tex \,,,\, }}
    | unit    :: :: unit  {{ tex \langle \rangle }}
    | Unit    :: :: Unit  {{ tex \langle \rangle }}
    | top     :: :: top  {{ tex \mathsf{top} }}
    | topArr  :: :: topArr  {{ tex \mathsf{top}_{\rightarrow} }}
    | distArr :: :: distArr  {{ tex \mathsf{dist}_{\rightarrow} }}
    | &       :: :: And  {{ tex \, \& \, }}
    | =>      :: :: Infer  {{ tex \Rightarrow }}
    | <=      :: :: Chk  {{ tex \Leftarrow }}
    | dir     :: :: dir {{ tex \Leftrightarrow }}
    | **      :: :: Dis  {{ tex * }}
    | ~~>     :: :: leads  {{ tex \rightsquigarrow }}
    | ~>      :: :: to       {{ tex \mapsto  }}
    | __      :: :: hole    {{ tex [\cdot] }}
    | ~=      :: :: ctxeq  {{ tex \backsimeq_{ctx} }}
    | <|:     :: :: sub {{ tex <: }}
    | tri  :: :: match {{ tex \triangleright }}


formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | | formula | :: :: multi       {{ tex \overline{[[formula]]}^{i \in 1 .. n}   }}
  | SD |- AA1 ** ... ** AAn               :: :: dis
  | x : T in gg               ::   :: inG {{ tex ( [[x]] : [[T]] ) \in [[gg]] }}
  | x : A in GG               ::   :: inGG {{ tex ( [[x]] : [[A]] ) \in [[GG]] }}
  | x : AA in SD               ::   :: inGG2 {{ tex ( [[x]] : [[AA]] ) \in [[SD]] }}
  | X ** A  in DD    ::   :: sbinds2 {{ tex ( [[X]] [[**]] [[A]] ) \in [[DD]] }}
  | X in dd          ::   :: sbind4 {{ tex  [[X]]  \in [[dd]] }}
  | X ** AA  in SD    ::   :: sbinds3 {{ tex ( [[X]] [[**]] [[AA]] ) \in [[SD]] }}
  | XX <: YY  in SS    ::   :: sbinds4 {{ tex ( [[XX]] <: [[YY]] ) \in [[SS]] }}
  | x notin dom G            ::   :: notInGx {{ tex [[x]] \notin [[G]] }}
  | x notin dom GG            ::   :: notInGGx {{ tex [[x]] \notin [[GG]] }}
  | e -->> e'       :: :: multi_step
  | l1 <> l2 :: :: label {{ tex [[l1]] \neq [[l2]] }}
  | A <: B  :: :: sub
  | A <|: B  :: :: sub2
  | GG  |- ee dir A :: :: inferChk
  | DD ; GG  |- ee dir A :: :: inferChk2
  | SD ; SG  |- E dir AA :: :: sedel
  | GG |- A :: :: well
  | cc : ( gg |- T ) ~> ( gg' |- T' ) :: :: ctxt
  | gg |- T :: :: hole
  | GG |- e1 == e2 : A ; B :: :: logeq3 {{ tex [[GG]] [[|-]] \logeq{[[e1]]}{[[e2]]} : [[A]] ; [[B]] }}
  | DD ; GG  |- e1 == e2 : A ; B :: :: logeq5 {{ tex [[DD]] ; [[GG]] [[|-]] \logeq{[[e1]]}{[[e2]]} : [[A]] ; [[B]] }}
  | GG |- e1 == e2 : A  :: :: logeq4 {{ tex [[GG]] [[|-]] \logeq{[[e1]]}{[[e2]]} : [[A]] }}
  | DD ; GG |- e1 == e2 : A  :: :: logeq6 {{ tex [[DD]] ; [[GG]] [[|-]] \logeq{[[e1]]}{[[e2]]} : [[A]] }}
  | gg |- e1 ~= e2 : T :: :: cxtx {{ tex [[gg]] [[|-]] \ctxeq{[[e1]]}{[[e2]]}{[[T]]} }}
  | GG |- ee1 ~= ee2 : A :: :: cxtx2
  | DD ; GG |- ee1 ~= ee2 : A :: :: cxtx3
  | ( v1 , v2 ) in V ( A ; B ) :: :: value2 {{ tex ( [[v1]] , [[v2]] ) \in \valR{[[A]]}{[[B]]} }}
  | ( v1 , v2 ) in V ( A ; B ) with pq :: :: value4 {{ tex ( [[v1]] , [[v2]] ) \in \valR{[[A]]}{[[B]]}_{[[pq]]} }}
  | ( v1 , v2 ) in V ( A  ) :: :: value {{ tex ( [[v1]] , [[v2]] ) \in \valRR{[[A]]} }}
  | ( v1 , v2 ) in V ( T  )  :: :: value5 {{ tex ( [[v1]] , [[v2]] ) \in \valRR{[[T]]} }}
  | ( v1 , v2 ) in V ( T  ) with pq :: :: value3 {{ tex ( [[v1]] , [[v2]] ) \in \valRR{[[T]]}_{[[pq]]} }}
  | ( v1 , v2 ) in V ( A  ) with pq :: :: valuee {{ tex ( [[v1]] , [[v2]] ) \in \valRR{[[A]]}_{[[pq]]} }}
  | ( e1 , e2 ) in E ( A ; B ) :: :: term2 {{ tex ( [[e1]] , [[e2]] ) \in \eeR{[[A]]}{[[B]]} }}
  | ( e1 , e2 ) in E ( A ; B ) with pq :: :: term4 {{ tex ( [[e1]] , [[e2]] ) \in \eeR{[[A]]}{[[B]]}_{[[pq]]} }}
  | ( e1 , e2 ) in E ( T  ) with pq :: :: term3 {{ tex ( [[e1]] , [[e2]] ) \in \eeRR{[[T]]}_{[[pq]]}    }}
  | ( e1 , e2 ) in E ( T  )  :: :: term5 {{ tex ( [[e1]] , [[e2]] ) \in \eeRR{[[T]]}   }}
  | ( e1 , e2 ) in E ( A  ) :: :: termm {{ tex ( [[e1]] , [[e2]] ) \in \eeRR{[[A]]}   }}
  | ( e1 , e2 ) in E ( A  ) with pq :: :: termmm {{ tex ( [[e1]] , [[e2]] ) \in \eeRR{[[A]]}_{[[pq]]}   }}
  | fs |- A <: B :: :: algo {{ tex [[fs]] [[|-]] [[A]] \prec : [[B]] }}
  | e : T :: :: typet
  | D ; GG |- ee : A :: :: types2 {{ tex [[D]] :: [[GG]] \vdash [[ee]] : [[A]] }}
  | ( g1 , g2 ) in GG  :: :: grel  {{ tex ([[g1]], [[g2]]) \in \ggR{[[GG]]} }}
  | ( g1 , g2 ) in GG with p  :: :: grel2  {{ tex ([[g1]], [[g2]]) \in \ggR{[[GG]]}_{[[p]]}  }}
  | ee -->> e :: :: red
  | p in DD  :: :: trel  {{ tex [[p]] \in \ddR{[[DD]]} }}
  | CC : ( DD ; GG dir A ) ~> ( DD' ; GG' dir' B ) ~~> cc :: :: typctx
  | A ord   :: :: ord {{ tex [[A]] \ \mathsf{ordinary} }}
  | A rigid :: :: Rigid {{ tex  [[A]] \ \mathsf{rigid} }}
  | A == B :: :: eqq {{ tex [[A]] \approx [[B]] }}


parsing
  sty_arrow <= sty_and
  sty_arrow right sty_arrow
  ty_arrow <= ty_prod
  ty_arrow right ty_arrow
  exp_abs <= exp_app


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% lambda^i subtyping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
JSubtype :: '' ::=

defn
A <: B ~~> e :: :: osub :: Si_ by


---------------------- :: int
nat <: nat ~~> \x . x



---------------------- :: top
A <: Top ~~> \x. unit



B1 <: A1 ~~> e1
A2 <: B2 ~~> e2
----------------------------------------------- :: arr
A1 -> A2 <: B1 -> B2 ~~> \f. \x. e2 (f (e1 x))


A1 <: A2 ~~> e1
A1 <: A3 ~~> e2
---------------------------- :: and
A1 <: A2 & A3 ~~> \x . < e1 x, e2 x >


A1 <: A3 ~~> e
A3 ord
------------------------- :: andL
A1 & A2 <: A3 ~~> \x . [ A3 , e (pp1 x) ]


A2 <: A3 ~~> e
A3 ord
------------------------------- :: andR
A1 & A2 <: A3 ~~> \x. [ A3 , e (pp2 x) ]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% lambda^i well-formedness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
WFi :: '' ::=

defn GG |- A :: :: WFi :: 'wf_' by

-------------- :: int
GG |- nat

-------------- :: top
GG |- Top


GG |- A
GG |- B
A ** B
---------------- :: and
GG |- A & B


GG |- A
GG |- B
---------------- :: arr
GG |- A -> B

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% lambda^i well-formedness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
JSTypi :: '' ::=

defn GG  ||- ee dir A ~~> e ::  :: h_type :: 'Ti_' by

----------------- :: top
GG ||- Top => Top ~~> unit


----------------- :: lit
GG ||- ii => nat ~~> ii


x : A in GG
--------------------- :: var
GG ||- x => A ~~> x


GG ||- ee1 => A1 -> A2 ~~> e1
GG ||- ee2 <= A1 ~~> e2
------------------------------- :: app
GG ||- ee1 ee2 => A2 ~~> e1 e2


GG ||- ee1 => A1 ~~> e1
GG ||- ee2 => A2 ~~> e2
A1 ** A2
----------------------------------------------- :: merge
GG ||- ee1 ,, ee2 => A1 & A2 ~~> < e1 , e2 >


GG ||- ee <= A ~~> e
------------------------- :: anno
GG ||- ee : A => A ~~> e


GG |- A
GG, x : A ||- ee <= B ~~> e
--------------------------------- :: abs
GG ||- \ x . ee <= A -> B ~~> \ x . e


GG |- B
GG ||- ee => A ~~> e
A <: B ~~> e'
--------------------- :: sub
GG ||- ee <= B ~~> e' e





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ subtyping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
JSubtyping :: '' ::=

defn
A <: B ~~> c :: :: sub :: S_ {{ tex [[A]] [[<:]] [[B]] \rulehl{[[~~>]] [[c]]} }}
by


---------------------- :: refl
A <: A ~~> id


A2 <: A3 ~~> c1
A1 <: A2 ~~> c2
----------------------- :: trans
A1 <: A3 ~~> c1 o c2


--------------- :: top
A <: Top ~~> top


--------------------------- :: topArr
Top <: Top -> Top ~~> topArr


------------------------------- :: topRcd
Top <: { l : Top } ~~> id


B1 <: A1 ~~> c1
A2 <: B2 ~~> c2
-------------------------------------- :: arr
A1 -> A2 <: B1 -> B2 ~~> c1 -> c2


A1 <: A2 ~~> c1
A1 <: A3 ~~> c2
---------------------------- :: and
A1 <: A2 & A3 ~~> <c1, c2>


------------------------- :: andL
A1 & A2 <: A1 ~~> pp1


----------------- :: andR
A1 & A2 <: A2 ~~> pp2



B1 <: B2 ~~> c
A2 <: A1
------------------------------------------------ :: forall
\ X ** A1 . B1 <: \ X ** A2 . B2  ~~> \ c


----------------------------------------------------- :: distArr
(A1 -> A2) & (A1 -> A3) <: A1 -> A2 & A3 ~~> distArr



A <: B ~~> c
------------------------------- :: rcd
{ l : A } <: { l : B } ~~> c


--------------------------------------------------- :: distRcd
{ l : A } & { l : B } <: { l : A & B } ~~> id




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ implicit subtyping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
ISubtyping :: '' ::=

defn
DD |- A <: B  :: :: isub :: IS_ by


DD |- t ** A1
DD |- [t / X]A2 <: B
------------------------------- :: allL
DD |- \X ** A1. A2 <: B



DD, X ** B1 |- A <: B2
-------------------------------- :: allR
DD |- A <: \X ** B1 . B2



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recursive type subtyping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
RSubtyping :: '' ::=

defn
SS |- A <: B  :: :: rsub :: RS_ by



SS , XX <: YY |- A <: B
----------------------------- :: amber
SS |- mu XX  . A <: mu YY . B



XX <: YY in SS
----------------------- :: var
SS |- XX <: YY


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ algorithmic subtyping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
JASubtype :: '' ::=

defn
fs |- A <: B ~~> c :: :: ASub :: A_
{{ tex [[fs]] [[|-]] [[A]] \prec : [[B]] [[~~>]] [[c]] }} by


------------------------- :: prim
[] |- pri <: pri ~~> id


[] |- A2 <: A1
[] |- B1 <: B2 ~~> c
----------------------------------------------- :: forall
[] |- \X ** A1 . B1 <: \X ** A2 . B2  ~~> \ c


------------------------- :: var
[] |- X <: X ~~> id


fs |- A <: B ~~> c
B rigid
--------------------------------------------- :: rcdR
{ l } , fs |- { l : A } <: B ~~> c



% fs |- A <: X ~~> c
% --------------------------------------------- :: rcdVar
% { l } , fs |- { l : A } <: X ~~> c


% fs |- A <: \ X ** B1 . B2 ~~> c
% --------------------------------------------------------- :: rcdAll
% { l } , fs |- { l : A } <: \ X ** B1 . B2 ~~> c



fs , { l } |- A <: B ~~> c
---------------------------- :: rcd
fs |- A <: { l : B } ~~> c


-------------------------- :: top
fs |- A <: Top ~~> < fs >1 o top



fs |- A <: B1 ~~> c1
fs |- A <: B2 ~~> c2
------------------------------------------------------- :: and
fs |- A <: B1 & B2 ~~> < fs >2 o <c1 , c2>


fs , B1 |- A <: B2 ~~> c
---------------------------- :: arr
fs |- A <: B1 -> B2 ~~> c



% fs |- A1 <: X ~~> c
% ---------------------------------- :: andVar1
% fs |- A1 & A2 <: X ~~> c o pp1


% fs |- A2 <: X ~~> c
% ---------------------------------- :: andVar2
% fs |- A1 & A2 <: X ~~> c o pp2



% fs |- A1 <: \X ** B1 . B2 ~~> c
% -------------------------------------------- :: andAll1
% fs |- A1 & A2 <: \X ** B1 . B2 ~~> c o pp1


% fs |- A2 <: \X ** B1 . B2 ~~> c
% ----------------------------------------------- :: andAll2
% fs |- A1 & A2 <: \X ** B1 . B2 ~~> c o pp2



fs |- A1 <: B ~~> c
B rigid
---------------------------------- :: andR1
fs |- A1 & A2 <: B ~~> c o pp1


fs |- A2 <: B ~~> c
B rigid
---------------------------------- :: andR2
fs |- A1 & A2 <: B ~~> c o pp2



% [] |- A <: A1 ~~> c1
% fs |- A2 <: X ~~> c2
% --------------------------------------- :: arrVar
% A, fs |- A1 -> A2 <: X ~~> c1 -> c2


% [] |- A <: A1 ~~> c1
% fs |- A2 <: \X ** B1 . B2 ~~> c2
% ------------------------------------------------- :: arrAll
% A, fs |- A1 -> A2 <: \X ** B1 . B2 ~~> c1 -> c2


[] |- A <: A1 ~~> c1
fs |- A2 <: B ~~> c2
B rigid
--------------------------------------- :: arrR
A, fs |- A1 -> A2 <: B ~~> c1 -> c2



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NeColus disjointness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Disjoint :: '' ::=

defn A ** B :: :: disjoint    :: 'D_'  by


--------------- :: topL
Top ** A


------------------ :: topR
A ** Top


A2 ** B2
--------------------- :: arr
A1 -> A2 ** B1 -> B2


A1 ** B
A2 ** B
--------------- :: andL
A1 & A2 ** B


A ** B1
A ** B2
--------------- :: andR
A ** B1 & B2


A ** B
------------------------ :: rcdEq
{ l : A } ** { l : B }



l1 <> l2
------------------------- :: rcdNeq
{ l1 : A } ** { l2 : B }


A **a B
-------------------- :: ax
A ** B


A ** B
------------------------ :: rec
mu XX . A ** mu YY . B





defns
DTyping :: '' ::=

defn ee : A  ::  :: he :: '' by


ee : A1
ee : A2
-------------- :: interI
ee : A1 & A2


ee1 : A
------------------- :: mergeL
ee1 ,, ee2 : A


ee2 : A
------------------- :: mergeR
ee1 ,, ee2 : A



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NeColus typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
JSTyping :: '' ::=

defn GG  |- ee dir A ~~> e ::  :: has_type :: 'T_'
{{ tex [[GG]] [[|-]] [[ee]] [[dir]] [[A]] \rulehl{[[~~>]] [[e]]} }}
by

----------------- :: top
GG |- Top => Top ~~> unit


----------------- :: lit
GG |- ii => pri ~~> ii



x : A in GG
--------------------- :: var
GG |- x => A ~~> x


GG |- ee1 => A1 -> A2 ~~> e1
GG |- ee2 <= A1 ~~> e2
------------------------------- :: app
GG |- ee1 ee2 => A2 ~~> e1 e2


GG |- ee1 => A1 ~~> e1
GG |- ee2 => A2 ~~> e2
A1 ** A2
----------------------------------------------- :: merge
GG |- ee1 ,, ee2 => A1 & A2 ~~> < e1 , e2 >


GG |- ee => A ~~> e
--------------------------------------------- :: rcd
GG |- { l = ee } => { l : A } ~~> e


GG |- ee => { l : A } ~~> e
-------------------------------- :: proj
GG |- ee.l => A ~~> e



GG |- ee <= A ~~> e
------------------------- :: anno
GG |- ee : A => A ~~> e


GG, x : A |- ee <= B ~~> e
--------------------------------- :: abs
GG |- \ x . ee <= A -> B ~~> \ x . e


GG |- ee => A ~~> e
A <: B ~~> c
--------------------- :: sub
GG |- ee <= B ~~> c e





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NeColus context typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns

JCTyping :: '' ::=

defn CC : ( GG dir A ) ~> ( GG' dir' B ) ~~> cc ::  :: CTyp :: 'CTyp_' by



--------------------------------------- :: empty1
__ : (GG => A) ~> (GG => A) ~~> __


----------------------------------------- :: empty2
__ : (GG <= A) ~> (GG <= A) ~~> __



CC : (GG => A) ~> (GG' => A1 -> A2) ~~> cc
GG' |- ee2 <= A1 ~~> e
----------------------------------------------- :: appL1
CC ee2 : (GG => A) ~> (GG' => A2) ~~> cc e


CC : (GG <= A) ~> (GG' => A1 -> A2) ~~> cc
GG' |- ee2 <= A1 ~~> e
----------------------------------------------- :: appL2
CC ee2 : (GG <= A) ~> (GG' => A2) ~~> cc e


GG' |- ee1 => A1 -> A2 ~~> e
CC : (GG => A) ~> (GG' <= A1) ~~> cc
-------------------------------------------- :: appR1
ee1 CC : (GG => A) ~> (GG' => A2) ~~> e cc


GG' |- ee1 => A1 -> A2 ~~> e
CC : (GG <= A) ~> (GG' <= A1) ~~> cc
----------------------------------------- :: appR2
ee1 CC : (GG <= A) ~> (GG' => A2) ~~> e cc



CC : (GG => A) ~> (GG' => A1) ~~> cc
GG' |- ee2 => A2 ~~> e
A1 ** A2
---------------------------------------------------------- :: mergeL1
CC ,, ee2 : (GG => A) ~> (GG' => A1 & A2) ~~> < cc , e >


CC : (GG <= A) ~> (GG' => A1) ~~> cc
GG' |- ee2 => A2 ~~> e
A1 ** A2
-------------------------------------------------------- :: mergeL2
CC ,, ee2 : (GG <= A) ~> (GG' => A1 & A2) ~~> < cc , e >



GG' |- ee1 => A1 ~~> e
CC : (GG => A) ~> (GG' => A2) ~~> cc
A1 ** A2
------------------------------------------------------ :: mergeR1
ee1 ,, CC : (GG => A) ~> (GG' => A1 & A2) ~~> < e , cc >


GG' |- ee1 => A1 ~~> e
CC : (GG <= A) ~> (GG' => A2) ~~> cc
A1 ** A2
------------------------------------------------------ :: mergeR2
ee1 ,, CC : (GG <= A) ~> (GG' => A1 & A2) ~~> < e , cc >




CC : (GG => A) ~> (GG' => B) ~~> cc
---------------------------------------------------- :: rcd1
{ l = CC } : (GG => A) ~> (GG' => { l : B }) ~~> cc


CC : (GG <= A) ~> (GG' => B) ~~> cc
---------------------------------------------------- :: rcd2
{ l = CC } : (GG <= A) ~> (GG' => { l : B }) ~~> cc



CC : (GG => A) ~> (GG' => { l : B }) ~~> cc
-------------------------------------------- :: proj1
CC.l : (GG => A) ~> (GG' => B) ~~> cc


CC : (GG <= A) ~> (GG' => { l : B }) ~~> cc
-------------------------------------------- :: proj2
CC.l : (GG <= A) ~> (GG' => B) ~~> cc


CC : (GG => B) ~> (GG' <= A) ~~> cc
------------------------------------------ :: anno1
CC : A : (GG => B) ~> (GG' => A) ~~> cc


CC : (GG <= B) ~> (GG' <= A) ~~> cc
---------------------------------------- :: anno2
CC : A : (GG <= B) ~> (GG' => A) ~~> cc



CC : (GG => A) ~> (GG', x : A1 <= A2) ~~> cc
x notin dom GG'
------------------------------------------------------- :: abs1
\ x . CC : (GG => A) ~> (GG' <= A1 -> A2) ~~> \x . cc


CC : (GG <= A) ~> (GG', x : A1 <= A2) ~~> cc
x notin dom GG'
------------------------------------------------------- :: abs2
\ x . CC : (GG <= A) ~> (GG' <= A1 -> A2) ~~> \x . cc



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ context typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns

JSCTyping :: '' ::=

defn CC : ( DD ; GG dir A ) ~> ( DD' ; GG' dir' B ) ~~> cc ::  :: FCTyp :: 'FCTyp_' {{ com context typing }} by


--------------------------------------- :: empty1
__ : (DD ; GG => A) ~> (DD ; GG => A) ~~> __


----------------------------------------- :: empty2
__ : (DD ; GG <= A) ~> (DD ; GG <= A) ~~> __



CC : (DD ; GG => A) ~> (DD' ; GG' => A1 -> A2) ~~> cc
DD' ; GG' |- ee2 <= A1 ~~> e
----------------------------------------------- :: appL1
CC ee2 : (DD ; GG => A) ~> (DD' ; GG' => A2) ~~> cc e


CC : (DD ; GG <= A) ~> (DD' ; GG' => A1 -> A2) ~~> cc
DD' ; GG' |- ee2 <= A1 ~~> e
----------------------------------------------- :: appL2
CC ee2 : (DD ; GG <= A) ~> (DD' ; GG' => A2) ~~> cc e


CC : (DD ; GG => A) ~> (DD' ; GG' <= A1) ~~> cc
DD' ; GG' |- ee1 => A1 -> A2 ~~> e
-------------------------------------------- :: appR1
ee1 CC : (DD ; GG => A) ~> (DD' ; GG' => A2) ~~> e cc


CC : (DD ; GG <= A) ~> (DD' ; GG' <= A1) ~~> cc
DD' ; GG' |- ee1 => A1 -> A2 ~~> e
----------------------------------------- :: appR2
ee1 CC : (DD ; GG <= A) ~> (DD' ; GG' => A2) ~~> e cc



CC : (DD ; GG => A) ~> (DD' ; GG' => A1) ~~> cc
DD' ; GG' |- ee2 => A2 ~~> e
DD' |- A1 ** A2
---------------------------------------------------------- :: mergeL1
CC ,, ee2 : (DD ; GG => A) ~> (DD' ; GG' => A1 & A2) ~~> < cc , e >


CC : (DD ; GG <= A) ~> (DD' ; GG' => A1) ~~> cc
DD' ; GG' |- ee2 => A2 ~~> e
DD' |- A1 ** A2
-------------------------------------------------------- :: mergeL2
CC ,, ee2 : (DD ; GG <= A) ~> (DD' ; GG' => A1 & A2) ~~> < cc , e >



CC : (DD ; GG => A) ~> (DD' ; GG' => A2) ~~> cc
DD' ; GG' |- ee1 => A1 ~~> e
DD' |- A1 ** A2
------------------------------------------------------ :: mergeR1
ee1 ,, CC : (DD ; GG => A) ~> (DD' ; GG' => A1 & A2) ~~> < e , cc >


CC : (DD ; GG <= A) ~> (DD' ; GG' => A2) ~~> cc
DD' ; GG' |- ee1 => A1 ~~> e
DD' |- A1 ** A2
------------------------------------------------------ :: mergeR2
ee1 ,, CC : (DD ; GG <= A) ~> (DD' ; GG' => A1 & A2) ~~> < e , cc >


CC : (DD ; GG => A) ~> (DD' ; GG' => B) ~~> cc
---------------------------------------------------- :: rcd1
{ l = CC } : (DD ; GG => A) ~> (DD' ; GG' => { l : B }) ~~> cc


CC : (DD ; GG <= A) ~> (DD' ; GG' => B) ~~> cc
---------------------------------------------------- :: rcd2
{ l = CC } : (DD ; GG <= A) ~> (DD' ; GG' => { l : B }) ~~> cc



CC : (DD ; GG => A) ~> (DD' ; GG' => { l : B }) ~~> cc
-------------------------------------------- :: proj1
CC.l : (DD ; GG => A) ~> (DD' ; GG' => B) ~~> cc


CC : (DD ; GG <= A) ~> (DD' ; GG' => { l : B }) ~~> cc
-------------------------------------------- :: proj2
CC.l : (DD ; GG <= A) ~> (DD' ; GG' => B) ~~> cc


CC : (DD ; GG => B) ~> (DD' ; GG' <= A) ~~> cc
------------------------------------------ :: anno1
CC : A : (DD ; GG => B) ~> (DD' ; GG' => A) ~~> cc


CC : (DD ; GG <= B) ~> (DD' ; GG' <= A) ~~> cc
---------------------------------------- :: anno2
CC : A : (DD ; GG <= B) ~> (DD' ; GG' => A) ~~> cc



CC : (DD ; GG => A) ~> (DD' ; GG', x : A1 <= A2) ~~> cc
DD' |- A1
------------------------------------------------------- :: abs1
\ x . CC : (DD ; GG => A) ~> (DD' ; GG' <= A1 -> A2) ~~> \x . cc


CC : (DD ; GG <= A) ~> (DD' ; GG', x : A1 <= A2) ~~> cc
DD' |- A1
------------------------------------------------------- :: abs2
\ x . CC : (DD ; GG <= A) ~> (DD' ; GG' <= A1 -> A2) ~~> \x . cc




CC : (DD ; GG => A) ~> (DD' , X ** B ; GG' => B') ~~> cc
DD' |- B
------------------------------------------------------- :: tabs1
\ X ** B . CC : (DD ; GG => A) ~> (DD' ; GG' => \ X ** B . B') ~~> \X . cc



CC : (DD ; GG <= A) ~> (DD' , X ** B ; GG' => B') ~~> cc
DD' |- B
------------------------------------------------------- :: tabs2
\ X ** B . CC : (DD ; GG <= A) ~> (DD' ; GG' => \ X ** B . B') ~~> \X . cc


CC : (DD ; GG => A) ~> (DD' ; GG' => \ X ** A1 . A2) ~~> cc
DD' |- t
DD' |- t ** A1
----------------------------------------------- :: tapp1
CC B : (DD ; GG => A) ~> (DD' ; GG' => [ t / X ] A2  ) ~~> cc |t|



CC : (DD ; GG <= A) ~> (DD' ; GG' => \ X ** A1 . A2) ~~> cc
DD' |- t
DD' |- t ** A1
----------------------------------------------- :: tapp2
CC B : (DD ; GG <= A) ~> (DD' ; GG' => [ t / X ] A2  ) ~~> cc |t|







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% coercion typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns

JCoTyping :: '' ::=

defn c |- T1 tri T2 ::  :: cotyp :: 'ct_' by


----------------------- :: refl
id |- T tri T



c1 |- T2 tri T3
c2 |- T1 tri T2
--------------------- :: trans
c1 o c2 |- T1 tri T3



---------------------  :: top
top |- T tri Unit



------------------------------  :: topArr
topArr |- Unit tri Unit -> Unit



c1 |- T1' tri T1
c2 |- T2 tri T2'
------------------------------------- :: arr
c1 -> c2 |- T1 -> T2 tri T1' -> T2'


c1 |- T1 tri T2
c2 |- T1 tri T3
----------------------------- :: pair
<c1, c2> |- T1 tri T2 * T3



-------------------------------------------------- :: distArr
distArr |- (T1 -> T2) * (T1 -> T3) tri T1 -> T2 * T3



--------------------- :: projl
pp1 |- T1 * T2 tri T1



--------------------- :: projr
pp2 |- T1 * T2 tri T2


% c |- T1 tri T2
% --------------------------------- :: rcd
% c |- {l : T1} tri {l : T2}


% ----------------------------- :: topRcd
% < l > |- Unit tri { l : Unit }



% ---------------------------------------------- :: distRcd
% distRcd l |- {l : T1} * {l : T2} tri {l : T1 * T2}


c |- T1 tri T2
---------------------------------- :: forall
\ c |- \ X . T1 tri \X . T2





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Target well-formedness of value contexts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jwf_env :: '' ::=

defn
dd |- gg :: :: wfe :: 'wfe_' by



--------- :: empty
dd |- empty


dd |- T
dd |- gg
---------------- :: var
dd |- gg , x : T


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Target well-formedness of types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
Jwft :: '' ::=

defn
dd |- T :: :: wft :: 'wft_' by



----------- :: unit
dd |- Unit


----------- :: int
dd |- nat


X in dd
----------------- :: var
dd |- X


dd |- T1
dd |- T2
--------------- :: arrow
dd |- T1 -> T2


dd |- T1
dd |- T2
--------------- :: prod
dd |- T1 * T2



dd, X |- T2
-------------------- :: all
dd |- \ X . T2



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NeColus Target typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns

JTyping :: '' ::=


defn
gg |- e : T ::   :: typing :: 't_' by


----------------- :: unit
gg |- unit : Unit


----------------- :: lit
gg |- ii : pri


x : T in gg
------------ :: var
gg |- x : T


gg, x : T1 |- e : T2
-------------------------- :: abs
gg |- \x. e : T1 -> T2


gg |- e1 : T1 -> T2
gg |- e2 : T1
------------------ :: app
gg |- e1 e2 : T2


gg |- e1 : T1
gg |- e2 : T2
------------------------------ :: pair
gg |- <e1, e2> : T1 * T2



gg |- e : T1
c |- T1 tri T2
------------------- :: capp
gg |- c e : T2


% gg |- e : T
% ---------------------------------- :: rcd
% gg |- { l = e } : { l : T }


% gg |- e : { l : T }
% ---------------------- :: proj
% gg |- e.l : T


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fco typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jtyping :: '' ::=

defn
dd ; gg |- e : T :: :: typ :: 'Ft_' by


dd |- gg
------------------ :: unit
dd ; gg |- unit : Unit


dd |- gg
------------- :: int
dd ; gg |- ii : pri



dd |- gg
x : T in gg
------------------ :: var
dd ; gg |- x : T




dd ; gg , x : T1 |- e : T2
dd |- T1
--------------------------- :: abs
dd ; gg |- \x . e : T1 -> T2




dd ; gg |- e1 : T1 -> T2
dd ; gg |- e2 : T1
--------------------- :: app
dd ; gg |- e1 e2 : T2


dd ; gg |- e1 : T1
dd ; gg |- e2 : T2
-------------------------- :: pair
dd ; gg |- <e1,  e2> : T1 * T2


dd , X ; gg |- e : T
dd |- gg
-------------------------- :: tabs
dd ; gg |- \X . e : \X. T



dd ; gg |- e : \X .T'
dd |- T
--------------------------- :: tapp
dd ; gg |- e T : [ T / X ] T'


dd ; gg |- e : T1
c |- T1 tri T2
dd |- T2
-------------------- :: capp
dd ; gg |- c e : T2



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% target reduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns

JEval :: '' ::=

defn
e --> e' :: :: step :: r_  by


-------------------- :: id
id v --> v


---------------------------- :: trans
(c1 o c2) v --> c1 (c2 v)


------------------ :: top
top v --> unit


----------------------- :: topArr
(topArr unit) unit --> unit



------------------------------------------- :: arr
((c1 -> c2) v1) v2 --> c2 (v1 (c1 v2))


-------------------------------- :: pair
<c1, c2> v --> <c1 v, c2 v>


--------------------------- :: forall
(\ c v) T --> c (v T)


------------------------------------------------- :: distArr
(distArr < v1 , v2 >) v3 --> < v1 v3, v2 v3 >


---------------------------- :: projl
pp1 <v1, v2> --> v1


---------------------------- :: projr
pp2 <v1, v2> --> v2


% -------------------------------- :: crcd
% {l : c} {l = v} --> { l = c v }



% ----------------------------- :: topRcd
% < l > unit --> { l = unit }



% -------------------------------------------- :: distRcd
% distRcd l < {l = v1} , {l = v2} > --> {l = <v1 , v2>}



% ----------------- :: projRcd
% {l = v}.l --> v


-------------------------------------  :: app
(\ x . e) v -->  [ v / x ] e


-------------------------------------  ::   tapp
(\ X . e) T -->  [ T / X ] e



e --> e'
---------------------------- :: ctxt
EE . e    -->  EE . e'



% e1 --> e1'
% ----------------------- :: app1
% e1 e2 --> e1' e2


% e2 --> e2'
% ----------------------- :: app2
% v1 e2 --> v1 e2'


% e1 --> e1'
% ----------------------- :: pair1
% <e1, e2> --> <e1', e2>


% e2 --> e2'
% ----------------------- :: pair2
% <v1, e2> --> <v1, e2'>


% e --> e'
% ---------------------- :: capp
% c e --> c e'


% e --> e'
% ----------------------- :: rcd1
% {l = e} --> {l = e'}


% e --> e'
% ----------------------- :: rcd2
% e.l --> e'.l



















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ type formation judgment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
Jswft :: '' ::=

defn
DD |- A :: :: swft :: 'swft_' by


----------- :: top
DD |- Top


----------- :: int
DD |- pri


X ** A  in DD
----------------- :: var
DD |- X


DD |- A
DD |- B
--------------- :: arrow
DD |- A -> B

DD |- A
DD , X ** A |- B
-------------------- :: all
DD |- \ X ** A . B


DD |- A
DD |- B
--------------- :: and
DD |- A & B


DD |- A
------------ :: rcd
DD |- { l : A }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ environment formation judgment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



defns
Jswf_env :: '' ::=

defn
DD ||- GG :: :: swfe :: 'swfe_'  by


--------- :: empty
DD ||- empty


DD ||- GG
DD |- A
---------------- :: var
DD ||- GG , x : A


defns
Jswf_tenv :: '' ::=

defn
||- DD :: :: swfte :: 'swfte_'  by


--------- :: empty
||- empty


||- DD
DD |- A
---------------- :: var
||- DD , X ** A





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ disjointness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
FDisjoint :: '' ::=

defn DD |- A ** B :: :: Fdisjoint    :: 'FD_'  {{ com Disjointness }} by


--------------- :: topL
DD |- Top ** A


------------------ :: topR
DD |- A ** Top


DD |- A2 ** B2
--------------------- :: arr
DD |- A1 -> A2 ** B1 -> B2


DD |- A1 ** B
DD |- A2 ** B
--------------- :: andL
DD |- A1 & A2 ** B


DD |- A ** B1
DD |- A ** B2
--------------- :: andR
DD |- A ** B1 & B2


DD |- A ** B
------------------------ :: rcdEq
DD |- { l : A } ** { l : B }


l1 <> l2
------------------------- :: rcdNeq
DD |- { l1 : A } ** { l2 : B }


X ** A in DD
A <|: B
-------------------------- :: tvarL
DD |- X ** B


X ** A in DD
A <|: B
-------------------------- :: tvarR
DD |- B ** X


DD , X ** A1 & A2 |- B1 ** B2
------------------------------------------- :: forall
DD |- \ X ** A1 . B1 ** \ X ** A2 . B2



A **a B
-------------------- :: ax
DD |- A ** B


defns
FDisAx :: '' ::=

defn A **a B :: :: FdisAx :: 'Dax_'  {{ tex [[A]] *_{ax} [[B]] }}
by



B **a A
---------- :: sym
A **a B


--------------------- :: intArr
pri **a A1 -> A2


------------------ :: intRcd
pri **a {l : A}



--------------------------------- :: intAll
pri **a \ X ** B1 . B2



------------------------------------ :: arrAll
A1 -> A2 **a \ X ** B1. B2



--------------------- :: arrRcd
A1 -> A2 **a {l : B}


------------------------------------ :: allRcd
\ X ** A1 . A2 **a {l : B}



--------------------------------- :: recRVar
mu YY . A **a XX


--------------------------------- :: intRVar
pri **a XX



--------------------------------- :: rcdRVar
{l : A} **a XX


--------------------------------- :: arrRVar
A1 -> A2 **a XX


--------------------------------- :: intRec
pri **a mu XX . B



--------------------------------- :: rcdRec
{l : A} **a mu XX . B


--------------------------------- :: arrRec
A1 -> A2 **a mu XX . B




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fi+ typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
FSTyping :: '' ::=

defn DD ; GG  |- ee dir A ~~> e ::  :: Ftyp :: 'FT_' by

||- DD
DD ||- GG
---------------------------- :: top
DD ; GG |- Top => Top ~~> unit



||- DD
DD ||- GG
-------------------------- :: int
DD ; GG |- ii => pri ~~> ii


||- DD
DD ||- GG
x : A in GG
--------------------- :: var
DD ; GG |- x => A ~~> x


DD ; GG |- ee1 => A1 -> A2 ~~> e1
DD ; GG |- ee2 <= A1 ~~> e2
------------------------------- :: app
DD ; GG |- ee1 ee2 => A2 ~~> e1 e2


DD ; GG |- ee1 => A ~~> e1
DD |- A tri A1 -> A2
DD ; GG |- ee2 <= A1 ~~> e2
------------------------------- :: appI
DD ; GG |- ee1 ee2 => A2 ~~> e1 e2


DD , X ** A; GG |- ee <= B ~~> e
------------------------------------------- :: gen
DD ; GG |- ee <= \X ** A . B ~~> \X . e


DD ; GG |- ee1 => A1 ~~> e1
DD ; GG |- ee2 => A2 ~~> e2
DD |- A1 ** A2
----------------------------------------------- :: merge
DD ; GG |- ee1 ,, ee2 => A1 & A2 ~~> < e1 , e2 >


DD ; GG |- ee <= A ~~> e
------------------------- :: anno
DD ; GG |- ee : A => A ~~> e


DD |- A
DD , X ** A ; GG |- ee => B ~~> e
----------------------------------------------- :: tabs
DD ; GG |- \ X ** A . ee => \ X ** A . B ~~> \ X . e



DD ; GG |- ee => \ X ** A . B ~~> e
DD |- t
DD |- t ** A
-------------------------------------------- :: tapp
DD ; GG |- ee t => [ t / X ] B  ~~>  e | t |



DD ; GG |- ee => A ~~> e
--------------------------------- :: rcd
DD ; GG |- {l = ee} => {l : A} ~~> e



DD ; GG |- ee => {l : A} ~~> e
------------------------------- :: proj
DD ; GG |- ee.l => A ~~> e


DD |- A
DD ; GG, x : A |- ee <= B ~~> e
------------------------------------------- :: abs
DD ; GG |- \x . ee <= A -> B ~~> \x . e


DD ; GG |- ee => B ~~> e
DD |- A
B <: A ~~> c
--------------------- :: sub
DD ; GG |- ee <= A ~~> c e



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Matching
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
DMatching :: '' ::=

defn

DD |- A tri B ::  :: dmatching :: m_ by

DD |- t ** A1
DD |- [t / X] A1 tri B1 -> B2
-------------------------------- :: forall
DD |- \X ** A1 . A2 tri B1 -> B2


-------------------------- :: arr
DD |- A1 -> A2 tri A1 -> A2








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SEDEL type well-formedness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JWF :: '' ::=

defn SD |- AA :: :: WF :: 'WF_' by


--------- :: top
SD |- Top


--------- :: int
SD |- pri


SD |- AA
SD |- BB
---------------- :: arr
SD |- AA -> BB


SD |- AA
------------- :: rcd
SD |- {l : AA}


X ** AA in SD
-------------- :: var
SD |- X


SD |- AA
SD |- BB
---------------- :: and
SD |- AA & BB


SD |- AA
SD , X ** AA |- BB
-------------------------- :: forall
SD |- \ X ** AA . BB


SD |- AA
SD |- BB
---------------- :: trait
SD |- Trait[AA,BB]





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SEDEL disjointness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
SDisjoint :: '' ::=

defn SD |- AA ** BB :: :: Sdisjoint    :: 'SD_'  {{ com Disjointness }} by


------------------- :: topL
SD |- Top ** AA


------------------- :: topR
SD |- AA ** Top



X ** AA in SD
AA <: BB
-------------------- :: tvarL
SD |- X ** BB


X ** AA in SD
AA <: BB
-------------------- :: tvarR
SD |- BB ** X



SD , X ** AA1 & AA2 |- BB1 ** BB2
------------------------------------------------- :: forall
SD |- \ X ** AA1 . BB1 ** \ X ** AA2 . BB2


SD |- AA ** BB
-------------------------- :: rcdEq
SD |- {l : AA} ** {l : BB}



l1 <> l2
-------------------------- :: rcdNeq
SD |- {l1 : AA} ** {l2 : BB}


SD |- AA2 ** BB2
---------------------------- :: arr
SD |- AA1 -> AA2 ** BB1 -> BB2


SD |- AA1 ** BB
SD |- AA2 ** BB
-------------------- :: andL
SD |- AA1 & AA2 ** BB


SD |- AA ** BB1
SD |- AA ** BB2
-------------------- :: andR
SD |- AA ** BB1 & BB2


AA **a BB
-------------------- :: ax
SD |- AA ** BB



SD |- AA2 ** BB2
--------------------------------- :: trait
SD |- Trait[AA1, AA2] ** Trait[BB1, BB2]


SD |- AA2 ** BB2
--------------------------------- :: traitArr1
SD |- Trait[AA1, AA2] ** BB1 -> BB2


SD |- AA2 ** BB2
--------------------------------- :: traitArr2
SD |- AA1 -> AA2 ** Trait[BB1, BB2]



defns
DisAx :: '' ::=

defn AA **a BB :: :: disAx :: 'SDax_'  {{ tex [[AA]] *_{ax} [[BB]] }}
by



BB **a AA
---------- :: sym
AA **a BB


--------------------- :: intArr
pri **a AA1 -> AA2


------------------ :: intRcd
pri **a {l : AA}



--------------------------------- :: intAll
pri **a \ X ** BB1 . BB2


--------------------------------- :: intTrait
pri **a Trait[AA1,AA2]



------------------------------------ :: arrAll
AA1 -> AA2 **a \ X ** BB1. BB2



--------------------- :: arrRcd
AA1 -> AA2 **a {l : BB}


-------------------------------------- :: traitAll
Trait[AA1,AA2] **a \ X ** BB1 . BB2


------------------------- :: traitRcd
Trait[AA1,AA2] **a {l : BB}



------------------------------------ :: allRcd
\ X ** AA1 . AA2 **a {l : BB}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SEDEL subtyping
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
SSubtyping :: '' ::=

defn
AA <: BB :: :: Ssubtyping :: 'TS_' by


-------------- :: refl
AA <: AA


AA2 <: AA3
AA1 <: AA2
----------------------- :: trans
AA1 <: AA3


---------- :: top
AA <: Top


AA1 <: AA2
AA1 <: AA3
----------------- :: and
AA1 <: AA2 & AA3


-------------- :: andL
AA1 & AA2 <: AA1


-------------- :: andR
AA1 & AA2 <: AA2


AA <: BB
-------------------- :: rcd
{l : AA} <: {l : BB}


BB1 <: AA1
AA2 <: BB2
-------------------- :: arr
AA1 -> AA2 <: BB1 -> BB2


BB1 <: BB2
AA2 <: AA1
------------------------------------------------ :: forall
\ X ** AA1. BB1 <: \ X ** AA2 . BB2


BB1 <: AA1
AA2 <: BB2
--------------------------------- :: trait
Trait[AA1, AA2] <: Trait[BB1, BB2]


--------------------------- :: topArr
Top <: Top -> Top


------------------------------- :: topRcd
Top <: { l : Top }


----------------------------------------------------- :: distArr
(AA1 -> AA2) & (AA1 -> AA3) <: AA1 -> AA2 & AA3

--------------------------------------------------- :: distRcd
{ l : AA } & { l : BB } <: { l : AA & BB }



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SEDEL typing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
SSTyping :: '' ::=

defn SD ; SG  |- E dir AA ~~> ee ::  :: Styp :: 'ST_'
by



------------------------- :: top
SD ; SG |- Top => Top ~~> Top


------------------------- :: int
SD ; SG |- ii => pri ~~> ii


x : AA in SD
------------------------- :: var
SD ;SG |- x => AA ~~> x


SD ; SG |- E <= AA ~~> ee
--------------------------------- :: anno
SD ; SG |- E : AA => AA ~~> ee : |AA|



SD ; SG |- E1 => AA1 -> AA2 ~~> ee1
SD ; SG |- E2 <= AA1 ~~> ee2
-------------------------------------- :: app
SD ; SG |- E1 E2 => AA2 ~~> ee1 ee2


SD ; SG |- E => \ X ** BB1 . BB2 ~~> ee
SD |- AA
SD |- AA ** BB1
------------------------------ :: tapp
SD; SG |- E AA => [AA / X] BB2 ~~> ee |AA|


SD ; SG |- E1 => AA ~~> ee1
SD ; SG |- E2 => BB ~~> ee2
SD |- AA ** BB
---------------------------------- :: merge
SD ; SG |- E1 ,, E2 => AA & BB ~~> ee1 ,, ee2


SD ; SG |- E => AA ~~> ee
------------------------------------------- :: rcd
SD ; SG |- {l = E} => {l : AA} ~~> {l = ee}


SD ; SG |- E => {l : AA} ~~> ee
--------------------------- :: proj
SD ; SG |- E.l => AA ~~> ee.l



SD |- AA
SD , X ** AA ; SG |- E => BB ~~> ee
--------------------------------------------------------------------- :: tabs
SD; SG |- \ X ** AA . E => \ X ** AA . BB ~~> \ X ** |AA| . ee


SD ; SG, x : AA |- E1 <= AA ~~> ee1
SD ; SG, x : AA |- E2 => BB ~~> ee2
---------------------------------------------------------- :: letrec
SD ; SG |- letrec x : AA = E1 in E2 => BB ~~> letrec x : |AA| = ee1 in ee2


| SD ; SG |- Ei => Trait[AAi, BBi] ~~> eei |
| AA <: AAi |
SD |- BB1 ** .. ** BBn
BB1 & .. & BBn <: AA
----------------------------------------------------------------------------------------------------------------------- :: new
SD ; SG |- new [ AA ] ( </ Ei // i IN 1..n /> ) => AA ~~> letrec self : |AA| = </ (eei self) // i IN 1..n />  in self


| SD ; SG, self : BB |- Ei => Trait[BBi, CTi] ~~> eei |
SD ; SG, self : BB |- { </ lj = Ej' // j IN 1..m /> } => CT ~~> ee
| BB <: BBi |
SD |- CT1 ** .. ** CTn ** CT
CT1 & .. & CTn & CT <: AA
--------------------------------------------------------------------------------------------------------------- :: trait
SD ; SG |- trait [ self : BB ] inherits </ Ei // i IN 1..n /> { </ lj = Ej' // j IN 1..m /> } : AA => Trait[BB, AA] ~~> lam self  . ((</ (eei self) // i IN 1..n />)  ,, ee)



SD ; SG |- E1 => Trait[AA, BB] ~~> ee1
SD ; SG |- E2 <= AA ~~> ee2
-------------------------- :: forward
SD ; SG |- E1 ^ E2 => BB ~~> ee1 ee2



| SD; SG, self : BB |- Ei => Trait[BBi, CTi] ~~> eei |
SD ; SG, self : BB, super : CT1 & .. & CTn |- { </ lj = Ej' // j IN 1..m /> } => CT ~~> ee
| BB <: BBi |
SD |- CT1 ** .. ** CTn ** CT
CT1 & .. & CTn & CT <: AA
--------------------------------------------------------------------------------------------------------------- :: traitSuper
SD ; SG |- trait [ self : BB ] inherits </ Ei // i IN 1..n /> { </ lj = Ej' // j IN 1..m /> } : AA => Trait[BB, AA] ~~> lam self . (let super = </ (eei self) // i IN 1..n /> in super ,, ee)



SD |- AA
SD ; SG , x : AA |- E <= BB ~~> ee
-------------------------------------- :: abs
SD ; SG |- \ x . E <= AA -> BB ~~> \x . ee



SD ; SG |- E => AA ~~> ee
AA <: BB
SD |- BB
-------------------------------- :: sub
SD ; SG |- E <= BB ~~> ee
