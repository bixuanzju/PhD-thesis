
\section{Overview}

In this section we give an overview of
disjoint polymorphism~\citep{alpuimdisjoint}, a variant of parametric polymorphism. The main novelty
is \textit{disjoint (universal) quantification} of the form
$[[ \ X ** A . B ]]$. Inspired by bounded quantification~\citep{cardelli1994extension} where a
type variable is constrained by a type bound, disjoint quantification allows
type variables to be associated with \textit{disjointness constraints}. Correspondingly, a
term construct of the form $[[ \ X ** A. ee ]]$ is used to create values of
disjoint quantification.

To understand the purpose of disjointness constraints, consider the following program (adapted from \citet{alpuimdisjoint}):
\begin{lstlisting}
mergeBad X (x : X) : X & Int = x ,, 2;
\end{lstlisting}
\lstinline{mergeBad} takes an argument \lstinline{x} of type \lstinline{X} (which is itself a type variable), and merges it with \lstinline{2}.
However, if we were to allow such definition, we could easily create an example where incoherence occurs again:
\begin{lstlisting}
(mergeBad Int 1) : Int -- 1 or 2
\end{lstlisting}
This is essentially the same problem of allowing $\mer{1}{2}$, which as we
discussed in \cref{bg:sec:intersection} will cause ambiguity. For \namee, we
know the concrete type for each variable and thus disjointness checking can help
avoid this problematic expression. However, with parametric polymorphism, a
variable could have any types,
including those that are already in the intersection. So a question to ask is to
decide under what conditions a type variable is disjoint with, say,
\lstinline{Int}. This is where disjointness constraints come onto stage. The key
idea is that since we do not know \textit{a priori} what is the type with which
a type variable can be instantiated, we can restrict the set of types it can be
instantiated to. Let us rewrite the above program as follows:
\begin{lstlisting}
mergeGood [X * Int] (x : X) : X & Int = x ,, 2;
\end{lstlisting}
The only change is the notation \lstinline{[X * Int]}, where the left-side of
\lstinline{*} denotes the type variable being declared, and the right-side
denotes the disjointness constraint(s). Here the disjointness constraint
(\lstinline{Int}) effectively states that the type variable \lstinline{X} can be
instantiated to any types disjoint with \lstinline{Int}. For instance, the expression \lstinline{mergeGood Bool True}
type checks but the expression \lstinline{mergeGood Int 1}
is rejected because \lstinline{Int} (the type argument) is not disjoint with
\lstinline{Int} (the disjointness constraint). What is more, we can express multiple
constraints using intersection types, for example,
\begin{lstlisting}
mergeThree [X * Int & Bool] (x : X) : X & Int & Bool = x ,, 2 ,, True;
\end{lstlisting}
Here the type variable \lstinline{X} can only be instantiated to types disjoint with both
\lstinline{Int} and \lstinline{Bool}.

In what follows, we first present the syntax and semantics (subtyping and typing) of \fnamee. We
then discuss the disjointness judgment in detail, in particular, the
disjointness relation between type variables and arbitrary types. Finally we
talk about the elaboration semantics of \fnamee and its target calculus \tnamee,
a variant of System F with explicit coercions.



% Local Variables:
% TeX-master: "../../Thesis"
% org-ref-default-bibliography: ../../Thesis.bib
% End:
