
\section{Elaboration and Type Safety}
\label{sec:elaboration:fi}



\begin{figure}
  \centering
\begin{tabular}{llll} \toprule
  Types & $[[T]]$ & $\Coloneqq$ & $[[int]] \mid [[Unit]] \mid [[T1 -> T2]]  \mid [[T1 * T2]] \mid \hlmath{[[X]] } \mid \hlmath{[[\ X . T]]}$\\
  Expressions & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[unit]] \mid [[\x . e]] \mid [[e1 e2]] \mid [[< e1 , e2>]]  \mid [[c e]] \mid \hlmath{[[\X . e]]} \mid \hlmath{[[ e T ]]}$ \\
  Coercions & $[[c]]$ & $\Coloneqq$ & $[[id]] \mid [[c1 o c2]] \mid [[top]] \mid [[c1 -> c2]] \mid [[< c1 , c2 >]] \mid [[pp1]] \mid [[pp2]] $ \\
  & & $\mid$ & $ [[distArr]] \mid [[topArr]]  \mid \hlmath{[[\ c]]} \mid \hlmath{[[topAll]]} \mid \hlmath{[[distPoly]]} $ \\
  Values & $[[v]]$ & $\Coloneqq$ & $[[i]] \mid [[unit]] \mid [[\x . e]] \mid [[< v1 , v2>]] \mid [[ (c1 -> c2) v ]] \mid [[distArr v]] \mid [[topArr v]] $ \\
  & & $\mid$ & $ \hlmath{[[\X . e]]} \mid \hlmath{[[\c v]]} \mid \hlmath{[[ topAll v ]]} \mid \hlmath{[[ distPoly v ]]}  $ \\
  Value Context & $[[gg]]$ & $\Coloneqq$ &  $[[empty]] \mid [[gg , x : T]] $ \\
  Type Context & $[[dd]]$ & $\Coloneqq$ &  $[[empty]] \mid [[dd , X ]] $ \\
  Evaluation Context & $[[EE]]$ & $\Coloneqq$ &  $  [[__]] \mid [[EE e]] \mid [[v EE]] \mid [[ < EE , e >  ]] \mid [[ < v , EE > ]] \mid [[ c EE  ]] \mid \hlmath{[[ EE T  ]]}  $ \\ \bottomrule
\end{tabular}
\caption{Syntax of \tnamee}
\label{fig:syntax:fco}
\end{figure}


Like \namee, the dynamic semantics of \fnamee is given by elaboration into
a target calculus. The target calculus \tnamee is the standard call-by-value
System F extended with products and coercions. The syntax of \tnamee is shown in
\cref{fig:syntax:fco}, with the differences from \tname \hll{highlighted}. We naturally
extend the type translation function $| \cdot |$ to cover type variables and
disjoint quantification as shown in \cref{def:type:translate:fi}. For disjoint
quantification, we simply erase the disjointness constraints and translate the body.

\begin{definition}[Type translation $|\cdot|$ from \fnamee to \tnamee] \label{def:type:translate:fi} \leavevmode

  \begin{center}
\begin{tabular}{lllllll} \toprule
  $| [[int]] |$ &$=$ & $ [[int]]$ &  &   $| [[Top]] |$ & $ = $ & $ \langle  \rangle $ \\
  $| [[A -> B]] |$ &$=$ & $[[ |A| -> |B| ]]$ &  &   $| [[A & B]] |$ & $ = $ & $[[ |A| * |B|    ]]$ \\
  $| [[ {l : A}  ]] |$ &$=$& $[[| A |]]$ & & $| [[X]] | $ &$=$ & $[[X]]$  \\
  $| [[\X ** A . B]] |$ & $ = $ & $[[\X . |B|]]$ \\ \bottomrule
\end{tabular}

  \end{center}
\end{definition}




\paragraph{Coercions and coercive subtyping.}

As shown in \cref{fig:syntax:fco}, we extend the coercions of \tname with new
coercion forms $[[ \ c ]]$, $[[distPoly]]$ and $[[topAll]]$. $[[ \ c ]]$ expresses the transformation between two
universal quantifiers. Now we go back to the coercion part in \rref{S-forall}.
Since the disjointness constraints are erased during elaboration, they do not
contribute to the overall coercion; we only need the coercion generated by the
subtyping of the bodies $[[B1]]$ and $[[B2]]$. As a cognitive aid, it is
instructive to mentally ``desugar'' the coercion $[[\ c]]$ to the regular term
$[[ \f . \ X . c (f X)]]$, as shown in \cref{tab:coercion2}, then the expression
$ [[\c v]] $ is ``equal'' to $[[ \X . c (v X) ]]$, which is why we can treat $[[ \c v]]$ as a value.


\begin{table}[t]
  \centering

\begin{tabular}{lllll} \toprule
  \textbf{Coercion} & \textbf{Term} & & \textbf{Coercion} & \textbf{Term} \\ \midrule
  $[[id]]$         & $[[ \x . x]]$  & & $[[ c1 o c2  ]]$    &  $[[  \x . c1 (c2 x) ]]$ \\
  $[[top]]$         & $[[ \x . unit ]]$  & & $[[ c1 -> c2  ]]$    &  $[[  \f . \x . c2 (f (c1 x))  ]]$ \\
  $[[  pp1   ]]$         & $[[ \x . pp1 x    ]]$  & & $[[ pp2  ]]$    &  $[[  \x . pp2 x  ]]$ \\
  $[[  < c1 , c2 >   ]]$         & $[[ \x . < c1 x, c2 x >    ]]$  & & $[[ distArr  ]]$    &  $[[  \x . \y . < (pp1 x) y , (pp2 x) y > ]]$ \\
  $[[  topArr   ]]$         & $[[ \x . \ y . unit    ]]$  & & $\hlmath{[[ \ c  ]]}$ &  $\hlmath{[[   \f . \ X . c (f X)    ]]}$   \\
  $\hlmath{[[  topAll   ]]}$         & $\hlmath{[[ \x . \ X . unit    ]]}$  & & $\hlmath{[[ distPoly  ]]}$ &  $\hlmath{[[   \f . \ X .< (pp1 f) X , (pp2 f) X >     ]]}$   \\ \bottomrule
\end{tabular}
  \caption{Correspondence between coercions and terms, extended}
  \label{tab:coercion2}
\end{table}



\paragraph{\tnamee static semantics.}

\begin{figure}
  \centering
  \drules[wfe]{$[[ dd |- gg   ]]$}{Well-formedness of value context}{empty, var}
  \drules[wft]{$[[ dd |- T   ]]$}{Well-formedness of types}{int, var, arrow,prod, all}
  \drules[Ft]{$[[ dd ; gg |- e : T ]]$}{Static semantics}{unit, int, var, abs, app, tabs, tapp, pair, capp}
  \caption{Typing rules of \tnamee}
  \label{fig:typing:fco}
\end{figure}

\Cref{fig:typing:fco} presents the typing rules of \tnamee. Most of the rules
are quite standard. \Rref{Ft-capp} uses the coercion typing judgment $[[ c |- T1 tri T2 ]]$.
We extend the coercion typing of \tname in \cref{fig:co} with three new rules, corresponding to three new coercion forms,
as shown below:
\begin{mathpar}
  \drule{ct-forall} \and
  \drule{ct-topAll} \and
  \drule{ct-distPoly}
\end{mathpar}


\paragraph{\tnamee dynamic semantics.}


\begin{figure}[t]
  \centering
  \begin{drulepar}[r]{$[[e --> e']]$}{Single-step reduction}{}
    \drule{id}
    \drule{trans}
    \drule{top}
    \drule{topArr}
    \drule{pair}
    \drule{arr}
    \drule{distArr}
    \drule{projl}
    \drule{projr} \and
    \hlmath{\drule{forall}} \and
    \hlmath{\drule{distPoly}} \and
    \hlmath{\drule{topAll}} \and
    \hlmath{\drule{tapp}} \and
    \drule{app}
    \drule{ctxt}
  \end{drulepar}
  \caption{Dynamic semantics of \tnamee}
  \label{fig:red:fi}
\end{figure}


We extend the evaluation context with one new form $[[EE T]]$ for type
applications, as shown in \cref{fig:syntax:fco}. The set of reduction rules for \tnamee in \cref{fig:red:fi}
is a straightforward extension of \tname. We
have a new reduction rule \rref*{r-forall} for the new coercion. This rule might look
strange at first. To have a better understanding, let us use the old trick of treating the coercion
$[[\ c]]$ as the term $[[ \f . \ X . c (f X) ]]$, then the application
$[[(\f . \ X . c (f X)) v T ]]$ reduces to $[[ c (v T) ]]$. Also we add the
reduction rule \rref*{r-tapp} for type applications. Now we can show that
\tnamee is type-safe in the usual sense:

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/TargetProperty.v\#L83}{\leftpointright} Preservation of \tnamee] % APPLYCOQ=PRESERVATION
  If $[[empty; empty |- e : T]]$ and $[[e --> e']]$, then $[[empty; empty |- e' : T]]$.
\end{theorem}

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/TargetProperty.v\#L9}{\leftpointright} Progress of \tnamee] % APPLYCOQ=PROGRESS
  If $[[empty; empty |- e : T]]$, then either $[[e]]$ is a value, or there exists $[[e']]$ such
  that $[[e --> e']]$.
\end{theorem}


\paragraph{Elaboration.}

We go back to the translation parts in \cref{fig:typing:fi}. The key idea of the
translation remains the same: we translate merges to pairs. For disjoint
quantification and disjoint type applications (\rref{FT-tabs,FT-tapp}), we
translate them to regular universal quantification and type applications,
respectively. For \rref{FT-rcd,FT-proj} we simply erase
the labels and translate the bare expressions. All the remaining
rules are ported from \namee. To conclude, we show an example translation:
\begin{align*}
  & [[ (\X ** int . (\x . x) : X -> X)  : \ X ** int . X & int -> X ]] \\
  \rightsquigarrow & \\
  & [[\ (pp1 -> id)  (\ X . \x . x)]]
\end{align*}

As with \namee, we show two lemmas that relate \fnamee to \tnamee.

\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SourceProperty.v\#L8}{\leftpointright} Coercions preserve types] % APPLYCOQ=COERCION_TYPES
  If $[[A <: B ~~> c]]$, then $[[c |-  |A| tri |B|]]$.
  \label{lemma:sub-correct:fi}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of subtyping.
\end{proof}


\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SourceProperty.v\#L44}{\leftpointright} Elaboration soundness] % APPLYCOQ=ELABORATION_SOUND
  We have that:
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of typing.
\end{proof}


\section{Algorithmic subtyping.}



\begin{figure}[t]
  \centering
  \begin{drulepar}[A]{$[[fs |- A <: B ~~> c]]$}{Algorithmic subtyping}{}
    \drule{and}
    \drule{arr}
    \drule{rcd}
    \drule{top} \and
    \hlmath{\drule{const}} \and
    \hlmath{\drule{arrConst}} \and
    \hlmath{\drule{rcdConst}} \and
    \hlmath{\drule{andConstOne}} \and
    \hlmath{\drule{andConstTwo}} \and
    \hlmath{\drule{forall}} \and
    \hlmath{\drule{allConst}}
  \end{drulepar}
  \caption{Algorithmic subtyping of \fnamee}
  \label{fig:algo:sub:fi}
\end{figure}

The algorithmic subtyping of \fnamee is a natural extension of \namee. From
\cref{fig:subtype_decl:fi}, an observation is that, as far as subtyping is
concerned, primitive types such as $[[int]]$ and type variables play exactly the
same role---i.e., they are neutral to subtyping. For conciseness of the
algorithmic rules, we add a new syntax category:
\[
  \text{Type Constants}\quad [[rho]] \Coloneqq  [[int]]  \mid [[X]]
\]

The full rules of the algorithmic subtyping of \fnamee is shown
\cref{fig:algo:sub:fi}. First we extend the syntax of $[[fs]]$ to include type
variables with their disjointness constraints:
\begin{definition} $[[fs => A]]$ is inductively defined as follows:
  \begin{center}
  \begin{tabular}{lll} \toprule
    $[[ [] => A]]$ &=& $[[A]]$ \\
    $[[ (B , fs) => A]]$ &=& $[[B -> (fs => A)]]$ \\
    $[[ (l , fs) => A]]$ &=& $[[{l : fs => A}]]$ \\
    $\hlmath{[[ (X ** B , fs) => A]]}$ &=& $\hlmath{[[\ X ** B . fs => A]]}$ \\ \bottomrule
  \end{tabular}
  \end{center}
\end{definition}

\Rref{A-const,A-arrConst,A-rcdConst,A-andConst1,A-andConst2} are generalizations
of the corresponding rules in \cref{fig:algorithm}---they deal with type
variables as well. \Rref{A-forall} is one of the new rules. Similar to
\rref{A-arr}, when a quantifier is encountered in $[[B]]$, \rref{A-forall}
pushes the type variables with its disjointness constraints onto $[[fs]]$ and
continue with the body. Correspondingly, in \rref{A-allConst}, when a quantifier is encountered in
$[[A]]$, and the head of $[[fs]]$ is a type variable, this variable is
popped out and we continue with the body.


\subsection{Correctness of the Algorithm}


\begin{figure}[t]
    \centering
    \begin{subfigure}[b]{0.5\textwidth}
      \begin{align*}
        [[ < [] >1 ]] &=  [[top]] \\
        [[ < l , fs >1 ]] &= [[ < fs >1 o id  ]] \\
        [[ < A , fs >1 ]] &= [[(top -> < fs >1) o topArr]] \\
        [[ < X ** A , fs >1 ]] &= [[ \ < fs >1 o topAll ]]
      \end{align*}
    \end{subfigure} ~
    \begin{subfigure}[b]{0.45\textwidth}
      \begin{align*}
        [[ < [] >2 ]] &=  [[id]] \\
        [[ < l , fs >2 ]] &= [[ < fs >2 o id  ]] \\
        [[ < A , fs >2 ]] &= [[(id -> < fs >2) o distArr]] \\
        [[ < X ** A , fs >2 ]] &= [[ \ < fs >2 o distPoly]]
      \end{align*}
    \end{subfigure}
    \caption{Meta-functions of coercions, extended}\label{fig:coercion_extend}
\end{figure}


Finally we show the correctness of the algorithmic subtyping. The two
meta-functions need to be updated to account for type variables, as shown in
\cref{fig:coercion_extend}. The proofs are along the same lines as in
\cref{sec:alg}. We refer the reader to our Coq formalization for more details.


\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SoundComplete.v\#L445}{\leftpointright} Soundness] % APPLYCOQ=ALGO_SOUND
  If $[[ fs |- A <: B ~~> c]]$ then $ [[   A <: fs => B ~~> c  ]]   $.
\end{theorem}

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SoundComplete.v\#L1742}{\leftpointright} Completeness] % APPLYCOQ=ALGO_COMPLETE
  If $[[A <: B ~~> c]]$ then there exists $[[c']]$ such that $[[ [] |- A <: B ~~> c']]$.
\end{theorem}



% \begin{remark}
%   As already can be seen, one drawback of our algorithmic subtyping is that the
%   size of rules grows exponentially as more constructs are added.
% \end{remark}
