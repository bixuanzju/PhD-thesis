
\section{Elaboration and Type Safety}
\label{sec:elaboration:fi}



\begin{figure}
  \centering
\begin{tabular}{llll} \toprule
  Types & $[[T]]$ & $\Coloneqq$ & $[[int]] \mid [[Unit]] \mid [[T1 -> T2]]  \mid [[T1 * T2]] \mid \hlmath{[[X]] } \mid \hlmath{[[\ X . T]]}$\\
  Expressions & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[unit]] \mid [[\x . e]] \mid [[e1 e2]] \mid [[< e1 , e2>]]  \mid [[c e]] \mid \hlmath{[[\X . e]]} \mid \hlmath{[[ e T ]]}$ \\
  Coercions & $[[c]]$ & $\Coloneqq$ & $[[id]] \mid [[c1 o c2]] \mid [[top]] \mid [[c1 -> c2]] \mid [[< c1 , c2 >]] \mid [[pp1]] \mid [[pp2]] $ \\
  & & $\mid$ & $ [[distArr]] \mid [[topArr]] \mid \hlmath{[[bot]]} \mid \hlmath{[[\ c]]} \mid \hlmath{[[topAll]]} \mid \hlmath{[[distPoly]]} $ \\
  Values & $[[v]]$ & $\Coloneqq$ & $[[i]] \mid [[unit]] \mid [[\x . e]] \mid [[< v1 , v2>]] \mid [[ (c1 -> c2) v ]] \mid [[distArr v]] \mid [[topArr v]] $ \\
  & & $\mid$ & $ \hlmath{[[\X . e]]} \mid \hlmath{[[\c v]]} \mid \hlmath{[[ topAll v ]]} \mid \hlmath{[[ distPoly v ]]}  $ \\
  Value Context & $[[gg]]$ & $\Coloneqq$ &  $[[empty]] \mid [[gg , x : T]] $ \\
  Type Context & $[[dd]]$ & $\Coloneqq$ &  $[[empty]] \mid [[dd , X ]] $ \\
  Evaluation Context & $[[EE]]$ & $\Coloneqq$ &  $  [[__]] \mid [[EE e]] \mid [[v EE]] \mid [[ < EE , e >  ]] \mid [[ < v , EE > ]] \mid [[ c EE  ]] \mid \hlmath{[[ EE T  ]]}  $ \\ \bottomrule
\end{tabular}
\caption{Syntax of \tnamee}
\label{fig:syntax:fco}
\end{figure}


Like \namee, the dynamic semantics of \fnamee is given by elaboration into a
target calculus. The target calculus \tnamee is the standard call-by-value
System F extended with products and coercions. The syntax of \tnamee is shown in
\cref{fig:syntax:fco}, with the differences from \tname \hll{highlighted}. We
extend the type translation function $| \cdot |$ to cover new constructs:
$[[Bot]]$ is mapped to an uninhabited type $[[\X . X]]$; disjoint quantification
is mapped to universal quantification, dropping the disjointness constraints.


\begin{definition}[Type translation $|\cdot|$ from \fnamee to \tnamee] \label{def:type:translate:fi} \leavevmode
  \begin{center}
\begin{tabular}{lllllll} \toprule
  $| [[int]] |$ &$=$ & $ [[int]]$ & $\qquad$  &   $| [[Top]] |$ & $ = $ & $ \langle  \rangle $ \\
  $| [[A -> B]] |$ &$=$ & $[[ |A| -> |B| ]]$ & $\qquad$ &   $| [[A & B]] |$ & $ = $ & $[[ |A| * |B|    ]]$ \\
  $| [[ {l : A}  ]] |$ &$=$& $[[| A |]]$ & $\qquad$ & $| [[X]] | $ &$=$ & $[[X]]$  \\
  $| [[\X ** A . B]] |$ & $ = $ & $[[\X . |B|]]$  & $\qquad$ & $| [[Bot]]  |$ & $=$ & $[[ \X . X ]]$\\ \bottomrule
\end{tabular}
  \end{center}
\end{definition}




\paragraph{Coercions and coercive subtyping.}

As shown in \cref{fig:syntax:fco}, we extend the coercions of \tname with several new
coercions: $[[bot]]$, $[[ \ c ]]$, $[[distPoly]]$ and $[[topAll]]$ due to the
addition of polymorphism and bottom type.
% Now we go back to the coercion part in \rref{S-forall}.
% Since the disjointness constraints are erased during elaboration, they do not
% contribute to the overall coercion; we only need the coercion generated by the
% subtyping of the bodies $[[B1]]$ and $[[B2]]$.
As a cognitive aid, we extend \cref{tab:coercion} with new desugaring rules as
shown in \cref{tab:coercion2}. For example, $[[\ c]]$ can be thought of as
$[[\f . \ X . c (f X)]]$, then the expression $ [[\c v]] $
is ``equal'' to $[[ \X . c (v X) ]]$, which is why we can treat $[[\c v]]$ as a value.


\begin{table}[t]
  \centering
\begin{tabular}{lllll} \toprule
  \textbf{Coercion} & \textbf{Term} & $\qquad$ & \textbf{Coercion} & \textbf{Term} \\ \midrule
  $[[id]]$         & $[[ \x . x]]$  & $\qquad$ & $[[ c1 o c2  ]]$    &  $[[  \x . c1 (c2 x) ]]$ \\
  $[[top]]$         & $[[ \x . unit ]]$  & $\qquad$ & $[[ c1 -> c2  ]]$    &  $[[  \f . \x . c2 (f (c1 x))  ]]$ \\
  $[[  pp1   ]]$         & $[[ \x . pp1 x    ]]$  & $\qquad$ & $[[ pp2  ]]$    &  $[[  \x . pp2 x  ]]$ \\
  $[[  < c1 , c2 >   ]]$         & $[[ \x . < c1 x, c2 x >    ]]$  & $\qquad$ & $[[ distArr  ]]$    &  $[[  \x . \y . < (pp1 x) y , (pp2 x) y > ]]$ \\
  $[[  topArr   ]]$         & $[[ \x . \ y . unit    ]]$  & $\qquad$ & $\hlmath{[[ \ c  ]]}$ &  $\hlmath{[[   \f . \ X . c (f X)    ]]}$   \\
  $\hlmath{[[  topAll   ]]}$         & $\hlmath{[[ \x . \ X . unit    ]]}$  & $\qquad$ & $\hlmath{[[ distPoly  ]]}$ &  $\hlmath{[[   \f . \ X .< (pp1 f) X , (pp2 f) X >     ]]}$   \\
  $\hlmath{[[  bot ]]}$         & $\hlmath{[[ \f . \ X . f X    ]]}$  \\ \bottomrule
\end{tabular}
  \caption{Correspondence between coercions and terms, extended}
  \label{tab:coercion2}
\end{table}



\paragraph{\tnamee static semantics.}

\begin{figure}
  \centering
  \drules[wfe]{$[[ dd |- gg   ]]$}{Well-formedness of value context}{empty, var}
  \drules[wft]{$[[ dd |- T   ]]$}{Well-formedness of types}{int, var, arrow,prod, all}
  \drules[Ft]{$[[ dd ; gg |- e : T ]]$}{Static semantics}{unit, int, var, abs, app, tabs, tapp, pair, capp}
  \caption{Typing rules of \tnamee}
  \label{fig:typing:fco}
\end{figure}

\Cref{fig:typing:fco} presents the typing rules of \tnamee. Most of the rules
are quite standard. \Rref{Ft-capp} uses the coercion typing judgment $[[ c |- T1 tri T2 ]]$.
We extend the coercion typing of \tname in \cref{fig:co} with four new rules, corresponding to the four new coercions:
\begin{mathpar}
  \drule{ct-bot} \and
  \drule{ct-forall} \and
  \drule{ct-topAll} \and
  \drule{ct-distAll}
\end{mathpar}


\paragraph{\tnamee dynamic semantics.}


\begin{figure}[t]
  \centering
  \drules[r]{$[[e --> e']]$}{Single-step reduction}{id, trans, top, topArr, pair, arr, distArr, projl, projr, forall, distAll, topAll, app, tapp, ctxt}
  % \begin{drulepar}[r]{$[[e --> e']]$}{Single-step reduction}{}
  %   \drule{id}
  %   \drule{trans}
  %   \drule{top}
  %   \drule{topArr}
  %   \drule{pair}
  %   \drule{arr}
  %   \drule{distArr}
  %   \drule{projl}
  %   \drule{projr} \and
  %   \hlmath{\drule{forall}} \and
  %   \hlmath{\drule{distPoly}} \and
  %   \hlmath{\drule{topAll}} \and
  %   \hlmath{\drule{tapp}} \and
  %   \drule{app}
  %   \drule{ctxt}
  % \end{drulepar}
  \caption{Dynamic semantics of \tnamee}
  \label{fig:red:fi}
\end{figure}


We extend the evaluation context with one new form $[[EE T]]$ for type
applications, as shown in \cref{fig:syntax:fco}. The set of reduction rules (\cref{fig:red:fi}) for \tnamee
is a straightforward extension of \tname. We
have three new reduction rules \rref*{r-forall,r-distAll,r-topAll} for the new coercions.
This rule might look
% strange at first. To have a better understanding, let us use the old trick of treating the coercion
% $[[\ c]]$ as the term $[[ \f . \ X . c (f X) ]]$, then the application
% $[[(\f . \ X . c (f X)) v T ]]$ reduces to $[[ c (v T) ]]$.
Also we add the reduction rule \rref*{r-tapp} for type applications. Now we can show that
\tnamee is type-safe in the usual sense:

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/TargetProperty.v\#L83}{\leftpointright} Preservation of \tnamee] % APPLYCOQ=PRESERVATION
  If $[[empty; empty |- e : T]]$ and $[[e --> e']]$, then $[[empty; empty |- e' : T]]$.
\end{theorem}

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/TargetProperty.v\#L9}{\leftpointright} Progress of \tnamee] % APPLYCOQ=PROGRESS
  If $[[empty; empty |- e : T]]$, then either $[[e]]$ is a value, or there exists $[[e']]$ such
  that $[[e --> e']]$.
\end{theorem}


\paragraph{Elaboration.}

We go back to the translation parts in \cref{fig:typing:fi}. The key idea of the
translation remains the same: we translate merges to pairs. For disjoint
quantification and disjoint type applications (\rref{FT-tabs,FT-tapp}), we
translate them to regular universal quantification and type applications,
respectively.
% For \rref{FT-rcd,FT-proj} we simply erase
% the labels and translate the bare expressions. All the remaining
% rules are ported from \namee.
To conclude, we show an example translation:
\begin{align*}
  & [[ (\X ** int . (\x . x) : X -> X)  : \ X ** int . X & int -> X ]] \\
  \rightsquigarrow & \\
  & [[\ (pp1 -> id)  (\ X . \x . x)]]
\end{align*}

As with \namee, we show two lemmas that relate \fnamee to \tnamee.

\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SourceProperty.v\#L8}{\leftpointright} Coercions preserve types] % APPLYCOQ=COERCION_TYPES
  If $[[A <: B ~~> c]]$, then $[[c |-  |A| tri |B|]]$.
  \label{lemma:sub-correct:fi}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of subtyping.
\end{proof}


\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SourceProperty.v\#L44}{\leftpointright} Elaboration soundness] % APPLYCOQ=ELABORATION_SOUND
  We have that:
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of typing.
\end{proof}


\section{Algorithmic System and Decidability}

The subtyping relation in \cref{fig:subtype_decl:fi} is highly non-algorithmic
due to the presence of a transitivity rule. This section presents an alternative
algorithmic formulation. The algorithmic subtyping extends that of \fnamee, to
handle disjoint quantifiers and the bottom type. We then prove that the
algorithm is sound and complete with respect to declarative subtyping.

Additionally we prove that the subtyping and disjointness relations are
decidable. Although the proofs of this fact are fairly straightforward, it is
nonetheless remarkable since it contrasts with the subtyping
relation for (full) \fsub~\citep{cardelli1985understanding}, which is
undecidable~\citep{pierce1994bounded}. Thus while bounded quantification is
infamous for its undecidability, disjoint quantification has the nicer property
of being decidable.

% \begin{figure}[t]
%   \centering
%   \begin{drulepar}[A]{$[[fs |- A <: B ~~> c]]$}{Algorithmic subtyping}{}
%     \drule{and}
%     \drule{arr}
%     \drule{rcd}
%     \drule{top} \and
%     \hlmath{\drule{const}} \and
%     \hlmath{\drule{arrConst}} \and
%     \hlmath{\drule{rcdConst}} \and
%     \hlmath{\drule{andConstOne}} \and
%     \hlmath{\drule{andConstTwo}} \and
%     \hlmath{\drule{forall}} \and
%     \hlmath{\drule{allConst}}
%   \end{drulepar}
%   \caption{Algorithmic subtyping of \fnamee}
%   \label{fig:algo:sub:fi}
% \end{figure}

% The algorithmic subtyping of \fnamee is a natural extension of \namee. From
% \cref{fig:subtype_decl:fi}, an observation is that, as far as subtyping is
% concerned, primitive types such as $[[int]]$ and type variables play exactly the
% same role---i.e., they are neutral to subtyping. For conciseness of the
% algorithmic rules, we add a new syntax category:
% \[
%   \text{Type Constants}\quad [[rho]] \Coloneqq  [[int]]  \mid [[X]]
% \]

% The full rules of the algorithmic subtyping of \fnamee is shown
% \cref{fig:algo:sub:fi}. First we extend the syntax of $[[fs]]$ to include type
% variables with their disjointness constraints:
% \begin{definition} $[[fs => A]]$ is inductively defined as follows:
%   \begin{center}
%   \begin{tabular}{lll} \toprule
%     $[[ [] => A]]$ &=& $[[A]]$ \\
%     $[[ (B , fs) => A]]$ &=& $[[B -> (fs => A)]]$ \\
%     $[[ (l , fs) => A]]$ &=& $[[{l : fs => A}]]$ \\
%     $\hlmath{[[ (X ** B , fs) => A]]}$ &=& $\hlmath{[[\ X ** B . fs => A]]}$ \\ \bottomrule
%   \end{tabular}
%   \end{center}
% \end{definition}

% \Rref{A-const,A-arrConst,A-rcdConst,A-andConst1,A-andConst2} are generalizations
% of the corresponding rules in \cref{fig:algorithm}---they deal with type
% variables as well. \Rref{A-forall} is one of the new rules. Similar to
% \rref{A-arr}, when a quantifier is encountered in $[[B]]$, \rref{A-forall}
% pushes the type variables with its disjointness constraints onto $[[fs]]$ and
% continue with the body. Correspondingly, in \rref{A-allConst}, when a quantifier is encountered in
% $[[A]]$, and the head of $[[fs]]$ is a type variable, this variable is
% popped out and we continue with the body.


% \subsection{Correctness of the Algorithm}


% \begin{figure}[t]
%     \centering
%     \begin{subfigure}[b]{0.5\textwidth}
%       \begin{align*}
%         [[ < [] >1 ]] &=  [[top]] \\
%         [[ < l , fs >1 ]] &= [[ < fs >1 o id  ]] \\
%         [[ < A , fs >1 ]] &= [[(top -> < fs >1) o topArr]] \\
%         [[ < X ** A , fs >1 ]] &= [[ \ < fs >1 o topAll ]]
%       \end{align*}
%     \end{subfigure} ~
%     \begin{subfigure}[b]{0.45\textwidth}
%       \begin{align*}
%         [[ < [] >2 ]] &=  [[id]] \\
%         [[ < l , fs >2 ]] &= [[ < fs >2 o id  ]] \\
%         [[ < A , fs >2 ]] &= [[(id -> < fs >2) o distArr]] \\
%         [[ < X ** A , fs >2 ]] &= [[ \ < fs >2 o distPoly]]
%       \end{align*}
%     \end{subfigure}
%     \caption{Meta-functions of coercions, extended}\label{fig:coercion_extend}
% \end{figure}


% Finally we show the correctness of the algorithmic subtyping. The two
% meta-functions need to be updated to account for type variables, as shown in
% \cref{fig:coercion_extend}. The proofs are along the same lines as in
% \cref{sec:alg}. We refer the reader to our Coq formalization for more details.

\subsection{Algorithmic Subtyping Rules}

Following \namee, we intend the algorithmic judgment $[[ fs |- A <: B ]]$ to be
equivalent to $[[ A <: fs => B ]]$, where $[[fs]]$ is a queue used to track record labels, domain types and disjointness constraints.
The syntax of $[[fs]]$ is shown below
\[
  [[fs]] \Coloneqq [[ []   ]] \mid [[ l , fs  ]] \mid [[  B , fs ]] \mid [[ X ** B , fs  ]]
\]
The full rules of the algorithmic subtyping of \fnamee are shown \cref{fig:algo:sub:fi}.

\begin{definition} $[[fs => A]]$ is inductively defined as follows:
  \begin{center}
  \begin{tabular}{lllllll} \toprule
    $[[ [] => A]]$ &=& $[[A]]$ & $\qquad$ & $[[ (B , fs) => A]]$ &=& $[[B -> (fs => A)]]$  \\
    $[[ (l , fs) => A]]$ &=& $[[{l : fs => A}]]$ & $\qquad$ & $[[ (X ** B , fs) => A]]$ &=& $[[\ X ** B . fs => A]]$ \\  \bottomrule
  \end{tabular}
  \end{center}
\end{definition}


\begin{figure}[t]
  \centering
  \drules[A]{$[[fs |- A <: B ~~> c]]$}{Algorithmic subtyping}{top,and,arr,rcd,forall,const, bot,arrConst,rcdConst,andConstOne,andConstTwo,allConst}
  \caption{Algorithmic subtyping}
  \label{fig:algo:sub:fi}
\end{figure}


For brevity of the algorithm, we use metavariable $[[rho]]$ to mean type constants:
\[
  \text{Type Constants}\quad [[rho]] \Coloneqq  [[int]] \mid [[Bot]] \mid [[X]]
\]
The basic idea of $[[ fs |- A <: B ]]$ is to perform a case analysis on $[[B]]$
until it reaches type constants. We explain new rules regarding disjoint
quantification and the bottom type.
When a quantifier is encountered in $[[B]]$, \rref{A-forall} pushes
the type variables with its disjointness constraints onto $[[fs]]$ and continue
with the body. Correspondingly, in \rref{A-allConst}, when a quantifier is
encountered in $[[A]]$, and the head of $[[fs]]$ is a type variable, this
variable is popped out and we continue with the body.
\Rref{A-bot} is similar to its declarative counterpart.
Two meta-functions $[[ < fs >1 ]]$
and $[[ < fs >2 ]]$ are meant to generate correct forms of coercions, and their
definitions are shown in \cref{fig:coercion_extend}.
% For other algorithmic rules, we refer to \namee~\cite{bi_et_al:LIPIcs:2018:9227} for detailed explanations.


\begin{figure}[t]
    \centering
    \begin{subfigure}[b]{0.5\textwidth}
      \begin{align*}
        [[ < [] >1 ]] &=  [[top]] \\
        [[ < l , fs >1 ]] &= [[ < fs >1 o id  ]] \\
        [[ < A , fs >1 ]] &= [[(top -> < fs >1) o topArr]] \\
        [[ < X ** A , fs >1 ]] &= [[ \ < fs >1 o topAll ]]
      \end{align*}
    \end{subfigure} ~
    \begin{subfigure}[b]{0.45\textwidth}
      \begin{align*}
        [[ < [] >2 ]] &=  [[id]] \\
        [[ < l , fs >2 ]] &= [[ < fs >2 o id  ]] \\
        [[ < A , fs >2 ]] &= [[(id -> < fs >2) o distArr]] \\
        [[ < X ** A , fs >2 ]] &= [[ \ < fs >2 o distPoly]]
      \end{align*}
    \end{subfigure}
    \caption{Meta-functions of coercions, extended}\label{fig:coercion_extend}
\end{figure}




\paragraph{Correctness of the algorithm.}

We prove that the algorithm is sound and complete with respect to the
specification. We refer the reader to our Coq formalization for more details.
We only show the two major theorems:



\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SoundComplete.v\#L445}{\leftpointright} Soundness] % APPLYCOQ=ALGO_SOUND
  If $[[ fs |- A <: B ~~> c]]$ then $ [[   A <: fs => B ~~> c  ]]   $.
\end{theorem}

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/SoundComplete.v\#L1742}{\leftpointright} Completeness] % APPLYCOQ=ALGO_COMPLETE
  If $[[A <: B ~~> c]]$ then there exists $[[c']]$ such that $[[ [] |- A <: B ~~> c']]$.
\end{theorem}


\subsection{Decidability}

Moreover, we prove that our algorithmic type system is decidable. To see this,
first notice that the bidirectional type system is syntax-directed, so we only
need to show decidability of algorithmic subtyping and
disjointness. The full (manual) proofs for decidability can be found in
\cref{appendix:decidable}.

\begin{restatable}[Decidability of algorithmic subtyping]{lemma}{decidesub} \label{lemma:decide-sub}
  Given $[[fs]]$, $[[A]]$ and $[[B]]$, it is decidable whether there exists
  $[[c]]$, such that $[[fs |- A <: B ~~> c]]$.
\end{restatable}
\begin{proof}
  Let the judgment $[[fs |- A <: B ~~> c]]$ be measured by $size([[fs]]) +
  size([[A]]) + size([[B]])$. For each subtyping rule, we can show that every
  inductive premise is smaller than the conclusion.
\end{proof}

\begin{restatable}[Decidability of disjointness checking]{lemma}{decidedis} \label{lemma:decide-dis}
  Given $[[DD]]$, $[[A]]$ and $[[B]]$, it is decidable whether $[[ DD |- A ** B ]]$.
\end{restatable}
\begin{proof}
  Let the judgment $[[ DD |- A ** B ]]$ be measured by $ size([[A]]) +
  size([[B]])$. For each subtyping rule, we can show that every inductive
  premise is smaller than the conclusion.
\end{proof}


One interesting observation here is that although our disjointness
quantification has a similar shape to bounded quantification $[[\/X<:A. B]]$ in
\fsub~\citep{cardelli1985understanding}, subtyping for \fsub~is
undecidable~\citep{pierce1994bounded}. In \fsub, the subtyping relation between
bounded quantification is:
\[
  \drule{fsub-forall}
\]
Compared with \rref{S-forall}, both rules are contravariant on
bounded/disjoint types, and covariant on the body. However, with bounded
quantification it is fundamental to track the bounds in the
environment, which complicates the design of the rules and makes
subtyping undecidable with \rref{fsub-forall}.
Decidability can be recovered
by employing an invariant rule for bounded quantification
(that is by forcing $[[A1]]$ and $[[A2]]$ to be identical).
Disjoint quantification does not require such invariant rule for
decidability.



% \begin{remark}
%   As already can be seen, one drawback of our algorithmic subtyping is that the
%   size of rules grows exponentially as more constructs are added.
% \end{remark}
