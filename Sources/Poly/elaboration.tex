
\section{Elaboration and Type Safety}
\label{sec:elaboration:fi}



\begin{figure}
  \centering
\begin{tabular}{llll} \toprule
  Types & $[[T]]$ & $\Coloneqq$ & $[[nat]] \mid [[Unit]] \mid [[T1 -> T2]]  \mid [[T1 * T2]] \mid [[X]] \mid [[\ X . T]]$\\
  Expressions & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[unit]] \mid [[\x . e]] \mid [[e1 e2]] \mid [[< e1 , e2>]] \mid [[\X . e]] \mid [[ e T ]] \mid [[c e]]$ \\
  Coercions & $[[c]]$ & $\Coloneqq$ & $[[id]] \mid [[c1 o c2]] \mid [[top]] \mid [[c1 -> c2]] \mid [[< c1 , c2 >]] \mid [[pp1]] \mid [[pp2]] \mid [[\ c]]$ \\
  & & $\mid$ & $ [[distArr]] \mid [[topArr]] $ \\
  Values & $[[v]]$ & $\Coloneqq$ & $[[i]] \mid [[unit]] \mid [[\x . e]] \mid [[< v1 , v2>]] \mid [[\X . e]] \mid [[ (c1 -> c2) v ]] \mid [[\c v]]  $ \\
  & & $\mid$ & $ [[distArr v]] \mid [[topArr v]] $ \\
  Value Contexts & $[[gg]]$ & $\Coloneqq$ &  $[[empty]] \mid [[gg , x : T]] $ \\
  Type Contexts & $[[dd]]$ & $\Coloneqq$ &  $[[empty]] \mid [[dd , X ]] $ \\ \bottomrule
  % Expression Contexts & $[[cc]]$ & $\Coloneqq$ &  $[[__]] \mid [[\ x . cc]] \mid [[\ X . cc]] \mid [[ cc T  ]] \mid [[cc e]] \mid [[e cc]] \mid [[< cc , e>]] \mid [[<e , cc>]] \mid [[c cc]] $
\end{tabular}
\caption{Syntax of \tnamee}
\label{fig:syntax:fco}
\end{figure}


Like \namee, the operation semantics of \fnamee is given by elaborating into
target expressions. The target calculus \tnamee is the standard call-by-value
System F extended with products and coercions. The syntax of \tnamee is shown in
\cref{fig:syntax:fco}. We naturally extend the type translation function $| \cdot |$
to cover type variables and disjoint quantification as shown in \cref{def:type:translate:fi}.
For disjoint quantification, we simply erase the disjointness constraint.

\begin{definition}[Type translation from \fnamee to \tnamee] \label{def:type:translate:fi}
  \begin{align*}
    | [[nat]] | &= [[nat]] \\
    | [[Top]] | &= \langle \rangle \\
    | [[A -> B]]  | &= [[ | A | -> | B |  ]] \\
    | [[ A & B  ]] | &= [[ | A | * | B |  ]] \\
    | [[ X  ]] | &= [[ X ]] \\
    | [[ \X ** A . B ]] | &= [[ \ X . | B | ]]
  \end{align*}
\end{definition}


\paragraph{Coercions and Coercive Subtyping.}

A notable difference from \tname is that \tnamee has no records. This is because
record labels are only useful for type-checking (and disjointness-checking)
purposes and thus have no effect at runtime.~\footnote{The argument also holds
  for \namee and \tname, but since the logical relation of \namee are indexed by
  \tname types, we have to keep records in \tname.} Correspondingly, coercions
in \tnamee do not contain $[[distRcd l]]$ and $[[ < l > ]]$. We add a new
coercion form $[[ \ c ]]$ which express the transformation between two universal
quantifiers. Now we go back to the coercion parts in \cref{fig:subtyping:fi}.
Most of them are the same as in \cref{fig:subtype_decl}. In \rref{FS-distRcd},
the coercion is simply $[[id]]$ because as we mentioned before labels are
erased, leading to the same type. The same goes to \rref{FS-topRcd}.
\Rref{FS-forall} is the new rule. Since disjointness constraint is erased, we
only need the coercion generated by the subtyping of the bodies $[[B1]]$ and
$[[B2]]$.


\paragraph{\tnamee Typing.}


\begin{figure}
  \centering
  \drules[wfe]{$[[ dd |- gg   ]]$}{Well-formedness of value contexts}{empty, var}
  \drules[wft]{$[[ dd |- T   ]]$}{Well-formedness of types}{int, var, arrow,prod, all}
  \drules[Ft]{$[[ dd ; gg |- e : T ]]$}{Typing}{unit, int, var, abs, app, tabs, tapp, pair, capp}
  \caption{Typing of \tnamee}
\end{figure}

The typing of \tnamee has the form $[[ dd ; gg |- e : T ]]$, where $[[dd]]$
denotes the type context and $[[gg]]$ the value context. Most of the rules are quite
standard. \Rref{Ft-capp} uses the coercion typing judgment $[[ c |- T1 tri T2 ]]$, which
is almost the same as in \cref{fig:co} (less \rref{ct-topRcd,ct-distRcd}), plus one new rule \rref*{ct-forall} as shown below:
\[
  \drule{ct-forall}
\]


\paragraph{\tnamee Dynamic Semantics.}

The dynamic semantics of \tnamee is call-by-value. The reduction rules for coercions are almost the same as in
\cref{fig:coercion_red} (less \rref{s-topRcd,s-distRcd}), plus one new rule \rref*{s-forall} as shown below:
\[
  \drule{s-forall}
\]
We show that \tnamee is type-safe.

\begin{theorem}[Preservation of \tnamee]
  If $[[empty; empty |- e : T]]$ and $[[e --> e']]$, then $[[empty; empty |- e' : T]]$.
\end{theorem}

\begin{theorem}[Progress of \tnamee]
  If $[[empty; empty |- e : T]]$, then either $[[e]]$ is a value, or there exists $[[e']]$ such
  that $[[e --> e']]$.
\end{theorem}


\paragraph{Elaboration.}

We go back to the translation parts in \cref{fig:typing:fi}. The key idea of the
translation remains the same: we translate merges to pairs. For disjoint
quantification and disjoint type applications (\rref{FT-tabs,FT-tapp}), we
translate them to regular universal quantification and type applications,
respectively. For \rref{FT-rcd,FT-proj} we simply erase
the labels and translate the corresponding underlying term. All the remaining
rules are ported from \namee.


As with \namee, we show two lemmas that relate \fnamee to \tnamee.

\begin{lemma}[Coercions preserve types]
  If $[[A <: B ~~> c]]$, then $[[c |-  |A| tri |B|]]$.
  \label{lemma:sub-correct:fi}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of subtyping.
\end{proof}


\begin{lemma}[Elaboration soundness] We have that:
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of typing.
\end{proof}
