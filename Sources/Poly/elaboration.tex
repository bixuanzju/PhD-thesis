
\section{Elaboration and Type Safety}
\label{sec:elaboration:fi}



\begin{figure}
  \centering
\begin{tabular}{llll} \toprule
  Types & $[[T]]$ & $\Coloneqq$ & $[[pri]] \mid [[Unit]] \mid [[T1 -> T2]]  \mid [[T1 * T2]] \mid \hlmath{[[X]] } \mid \hlmath{[[\ X . T]]}$\\
  Expressions & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[unit]] \mid [[\x . e]] \mid [[e1 e2]] \mid [[< e1 , e2>]]  \mid [[c e]] \mid \hlmath{[[\X . e]]} \mid \hlmath{[[ e T ]]}$ \\
  Coercions & $[[c]]$ & $\Coloneqq$ & $[[id]] \mid [[c1 o c2]] \mid [[top]] \mid [[c1 -> c2]] \mid [[< c1 , c2 >]] \mid [[pp1]] \mid [[pp2]] $ \\
  & & $\mid$ & $ [[distArr]] \mid [[topArr]] \mid \hlmath{[[\ c]]} $ \\
  Values & $[[v]]$ & $\Coloneqq$ & $[[i]] \mid [[unit]] \mid [[\x . e]] \mid [[< v1 , v2>]] \mid [[ (c1 -> c2) v ]] \mid [[distArr v]] \mid [[topArr v]] $ \\
  & & $\mid$ & $ \hlmath{[[\X . e]]} \mid \hlmath{[[\c v]]}  $ \\
  Value Context & $[[gg]]$ & $\Coloneqq$ &  $[[empty]] \mid [[gg , x : T]] $ \\
  Type Context & $[[dd]]$ & $\Coloneqq$ &  $[[empty]] \mid [[dd , X ]] $ \\
  Evaluation Context & $[[EE]]$ & $\Coloneqq$ &  $  [[__]] \mid [[EE e]] \mid [[v EE]] \mid [[ < EE , e >  ]] \mid [[ < v , EE > ]] \mid [[ c EE  ]] \mid \hlmath{[[ EE T  ]]}  $ \\ \bottomrule
\end{tabular}
\caption{Syntax of \tnamee}
\label{fig:syntax:fco}
\end{figure}


Like \namee, the dynamic semantics of \fnamee is given by elaboration into
a target calculus. The target calculus \tnamee is the standard call-by-value
System F extended with products and coercions. The syntax of \tnamee is shown in
\cref{fig:syntax:fco}, with the differences from \tname \hll{highlighted}. We naturally
extend the type translation function $| \cdot |$ to cover type variables and
disjoint quantification as shown in \cref{def:type:translate:fi}. For disjoint
quantification, we simply erase the disjointness constraints and translate the body.

\begin{definition}[Type translation from \fnamee to \tnamee] \label{def:type:translate:fi}
  \begin{align*}
    | [[pri]] | &= [[pri]] \\
    | [[Top]] | &= \langle \rangle \\
    | [[A -> B]]  | &= [[ | A | -> | B |  ]] \\
    | [[ A & B  ]] | &= [[ | A | * | B |  ]] \\
    | [[ X  ]] | &= [[ X ]] \\
    | [[ \X ** A . B ]] | &= [[ \ X . | B | ]]
  \end{align*}
\end{definition}


\paragraph{Coercions and Coercive Subtyping.}

As shown in \cref{fig:syntax:fco}, we extend the coercions of \tname with a new
coercion form $[[ \ c ]]$, which expresses the transformation between two
universal quantifiers. Now we go back to the coercion part in \rref{S-forall}.
Since the disjointness constraint is erased during elaboration, it does not
contribute to the overall coercion; we only need the coercion generated by the
subtyping of the bodies $[[B1]]$ and $[[B2]]$. As a cognitive aid, it is
instructive to mentally ``desugar'' the coercion $[[\ c]]$ to the regular term
$[[ \f . \ X . c (f X)]]$, as shown in \cref{tab:coercion2}, then the expression
$ [[\c v]] $ is ``equal'' to $[[ \X . c (v X) ]]$, which is why we can treat $[[ \c v]]$ as a value.


\begin{table}[t]
  \centering
\begin{tabular}{|l|l||l|l|}
\hline
\textbf{Coercion} & \textbf{Term} & \textbf{Coercion} & \textbf{Term} \\ \hline
$[[id]]$         & $[[ \x . x]]$  & $[[ c1 o c2  ]]$    &  $[[  \x . c1 (c2 x) ]]$     \\ \hline
$[[top]]$         & $[[ \x . unit ]]$  & $[[ c1 -> c2  ]]$    &  $[[  \f . \x . c2 (f (c1 x))  ]]$     \\ \hline
$[[  pp1   ]]$         & $[[ \x . pp1 x    ]]$  & $[[ pp2  ]]$    &  $[[  \x . pp2 x  ]]$     \\ \hline
$[[  < c1 , c2 >   ]]$         & $[[ \x . < c1 x, c2 x >    ]]$  & $[[ distArr  ]]$    &  $[[  \x . \y . < (pp1 x) y , (pp2 x) y > ]]$     \\ \hline
$[[  topArr   ]]$         & $[[ \x . \ y . unit    ]]$  & $\hlmath{[[ \ c  ]]}$ &  $\hlmath{[[   \f . \ X . c (f X)    ]]}$   \\ \hline
\end{tabular}
  \caption{Correspondence between coercions and terms, extended}
  \label{tab:coercion2}
\end{table}



\paragraph{\tnamee Static Semantics.}

\begin{figure}
  \centering
  \drules[wfe]{$[[ dd |- gg   ]]$}{Well-formedness of value context}{empty, var}
  \drules[wft]{$[[ dd |- T   ]]$}{Well-formedness of types}{int, var, arrow,prod, all}
  \drules[Ft]{$[[ dd ; gg |- e : T ]]$}{Static semantics}{unit, int, var, abs, app, tabs, tapp, pair, capp}
  \caption{Typing rules of \tnamee}
  \label{fig:typing:fco}
\end{figure}

\Cref{fig:typing:fco} presents the typing rules of \tnamee. Most of the rules
are quite standard. \Rref{Ft-capp} uses the coercion typing judgment $[[ c |- T1 tri T2 ]]$.
We extend the coercion typing of \tname in \cref{fig:co} with one new rule
\rref*{ct-forall} as shown below:
\[
  \drule{ct-forall}
\]


\paragraph{\tnamee Dynamic Semantics.}


\begin{figure}[t]
  \centering
  \begin{drulepar}[r]{$[[e --> e']]$}{Single-step reduction}{}
    \drule{id}
    \drule{trans}
    \drule{top}
    \drule{topArr}
    \drule{pair}
    \drule{arr}
    \drule{distArr}
    \drule{projl}
    \drule{projr} \and
    \hlmath{\drule{forall}} \and
    \hlmath{\drule{tapp}} \and
    \drule{app}
    \drule{ctxt}
  \end{drulepar}
  \caption{Dynamic semantics of \tnamee}
  \label{fig:red:fi}
\end{figure}


We extend the evaluation context with one new form $[[EE T]]$ for type
applications, as shown in \cref{fig:syntax:fco}. The set of reduction rules for \tnamee in \cref{fig:red:fi}
is a straightforward extension of \tname. We
have a new reduction rule \rref*{r-forall} for the new coercion. This rule might look
strange at first. To explain, let us use our old trick of treating the coercion
$[[\ c]]$ as the term $[[ \f . \ X . c (f X) ]]$, then the application
$[[(\f . \ X . c (f X)) v T ]]$ reduces to $[[ c (v T) ]]$. Also we add the
reduction rule \rref*{r-tapp} for type applications. Now we can show that
\tnamee is type-safe in the usual sense:

\begin{theorem}[Preservation of \tnamee]
  If $[[empty; empty |- e : T]]$ and $[[e --> e']]$, then $[[empty; empty |- e' : T]]$.
\end{theorem}

\begin{theorem}[Progress of \tnamee]
  If $[[empty; empty |- e : T]]$, then either $[[e]]$ is a value, or there exists $[[e']]$ such
  that $[[e --> e']]$.
\end{theorem}


\paragraph{Elaboration.}

We go back to the translation parts in \cref{fig:typing:fi}. The key idea of the
translation remains the same: we translate merges to pairs. For disjoint
quantification and disjoint type applications (\rref{FT-tabs,FT-tapp}), we
translate them to regular universal quantification and type applications,
respectively. For \rref{FT-rcd,FT-proj} we simply erase
the labels and translate the corresponding underlying term. All the remaining
rules are ported from \namee. To conclude, we show an example translation:
\begin{align*}
  & [[ (\X ** nat . (\x . x) : X -> X)  : \ X ** nat . X & nat -> X ]] \\
  \rightsquigarrow & \\
  & [[\ (pp1 -> id)  (\ X . \x . x)]]
\end{align*}

As with \namee, we show two lemmas that relate \fnamee to \tnamee.

\begin{lemma}[Coercions preserve types]
  If $[[A <: B ~~> c]]$, then $[[c |-  |A| tri |B|]]$.
  \label{lemma:sub-correct:fi}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of subtyping.
\end{proof}


\begin{lemma}[Elaboration soundness] We have that:
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of typing.
\end{proof}


\paragraph{Algorithmic subtyping.}



\begin{figure}[t]
  \centering
  \begin{drulepar}[A]{$[[fs |- A <: B ~~> c]]$}{Algorithmic subtyping}{}
    \drule{prim}
    \drule{and}
    \drule{arr}
    \drule{rcd}
    \drule{top} \and
    \hlmath{\drule{forall}} \and
    \hlmath{\drule{var}} \and
    \drule{arrR}
    \drule{rcdR}
    \drule{andROne}
    \drule{andRTwo}
  \end{drulepar}
  \caption{Algorithmic subtyping of \fnamee}
  \label{fig:algo:sub:fi}
\end{figure}

We extend the algorithmic subtyping for \namee with two rules
\rref*{A-forall,A-var}, as shown in \cref{fig:algo:sub:fi}. They are simple
adaptions from their declarative counterparts. Note that they all have empty
$[[fs]]$ because neither polymorphic types nor type variables have subtyping
relations with function types. We also need to extend the definition of rigid
types to include type variables and disjoint quantification, shown in
\cref{def:rigid:extended}, because as we can see in \cref{fig:subtype_decl:fi},
they do not have distributivity rules.

\begin{definition}[Rigid types, extended] \label{def:rigid:extended}
  \begin{mathpar}
    [[  pri rigid  ]] \and
    \hlmath{[[ X  rigid ]]} \and
    \hlmath{[[ \X ** A . B rigid ]]}
  \end{mathpar}
\end{definition}

Finally we show the correctness of the algorithmic subtyping:

\begin{conjecture}[Soundness]
  If $[[ fs |- A <: B ~~> c]]$ then $ [[   A <: fs -> B ~~> c  ]]   $.
\end{conjecture}

\begin{conjecture}[Completeness]
  If $[[A <: B ~~> c]]$ then there exists $[[c']]$ such that $[[ [] |- A <: B ~~> c']]$.
\end{conjecture}



% \begin{remark}
%   As already can be seen, one drawback of our algorithmic subtyping is that the
%   size of rules grows exponentially as more constructs are added.
% \end{remark}
