
\section{Elaboration and Type Safety}
\label{sec:elaboration:fi}



\begin{figure}
  \centering
\begin{tabular}{llll} \toprule
  Types & $[[T]]$ & $\Coloneqq$ & $[[pri]] \mid [[Unit]] \mid [[T1 -> T2]]  \mid [[T1 * T2]] \mid \hlmath{[[X]] } \mid \hlmath{[[\ X . T]]}$\\
  Expressions & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[unit]] \mid [[\x . e]] \mid [[e1 e2]] \mid [[< e1 , e2>]]  \mid [[c e]] \mid \hlmath{[[\X . e]]} \mid \hlmath{[[ e T ]]}$ \\
  Coercions & $[[c]]$ & $\Coloneqq$ & $[[id]] \mid [[c1 o c2]] \mid [[top]] \mid [[c1 -> c2]] \mid [[< c1 , c2 >]] \mid [[pp1]] \mid [[pp2]] $ \\
  & & $\mid$ & $ [[distArr]] \mid [[topArr]] \mid \hlmath{[[\ c]]} $ \\
  Values & $[[v]]$ & $\Coloneqq$ & $[[i]] \mid [[unit]] \mid [[\x . e]] \mid [[< v1 , v2>]] \mid [[ (c1 -> c2) v ]] \mid [[distArr v]] \mid [[topArr v]] $ \\
  & & $\mid$ & $ \hlmath{[[\X . e]]} \mid \hlmath{[[\c v]]}  $ \\
  Value Context & $[[gg]]$ & $\Coloneqq$ &  $[[empty]] \mid [[gg , x : T]] $ \\
  Type Context & $[[dd]]$ & $\Coloneqq$ &  $[[empty]] \mid [[dd , X ]] $ \\
  Evaluation Context & $[[EE]]$ & $\Coloneqq$ &  $  [[__]] \mid [[EE e]] \mid [[v EE]] \mid [[ < EE , e >  ]] \mid [[ < v , EE > ]] \mid [[ c EE  ]] \mid \hlmath{[[ EE T  ]]}  $ \\ \bottomrule
\end{tabular}
\caption{Syntax of \tnamee}
\label{fig:syntax:fco}
\end{figure}


Like \namee, the dynamic semantics of \fnamee is given by elaboration into
a target calculus. The target calculus \tnamee is the standard call-by-value
System F extended with products and coercions. The syntax of \tnamee is shown in
\cref{fig:syntax:fco}, with the differences from \tname \hll{highlighted}. We naturally
extend the type translation function $| \cdot |$ to cover type variables and
disjoint quantification as shown in \cref{def:type:translate:fi}. For disjoint
quantification, we simply erase the disjointness constraints and translate the body.

\begin{definition}[Type translation from \fnamee to \tnamee] \label{def:type:translate:fi}
  \begin{align*}
    | [[pri]] | &= [[pri]] \\
    | [[Top]] | &= \langle \rangle \\
    | [[A -> B]]  | &= [[ | A | -> | B |  ]] \\
    | [[ A & B  ]] | &= [[ | A | * | B |  ]] \\
    | [[ X  ]] | &= [[ X ]] \\
    | [[ \X ** A . B ]] | &= [[ \ X . | B | ]]
  \end{align*}
\end{definition}


\paragraph{Coercions and Coercive Subtyping.}

As shown in \cref{fig:syntax:fco}, we extend the coercions of \tname with a new
coercion form $[[ \ c ]]$, which expresses the transformation between two
universal quantifiers. Now we go back to the coercion part in \rref{S-forall}.
Since the disjointness constraint is erased during elaboration, it does not contribute to the
overall coercion; we only need the coercion generated by the subtyping of the
bodies $[[B1]]$ and $[[B2]]$. As a cognitive aid, it is instructive to mentally
``desugar'' the coercion $[[\ c]]$ to the regular term $[[ \f . \ X . c (f X)]]$, then
the expression $ [[\c v]] $ is ``equal'' to $[[  \X . c (v X) ]]$. This is why we treat
$[[ \c v ]]$ as a value.


\paragraph{\tnamee Static Semantics.}

\begin{figure}
  \centering
  \drules[wfe]{$[[ dd |- gg   ]]$}{Well-formedness of value context}{empty, var}
  \drules[wft]{$[[ dd |- T   ]]$}{Well-formedness of types}{int, var, arrow,prod, all}
  \drules[Ft]{$[[ dd ; gg |- e : T ]]$}{Static semantics}{unit, int, var, abs, app, tabs, tapp, pair, capp}
  \caption{Typing rules of \tnamee}
  \label{fig:typing:fco}
\end{figure}

\Cref{fig:typing:fco} presents the typing rules of \tnamee. Most of the rules
are quite standard. \Rref{Ft-capp} uses the coercion typing judgment $[[ c |- T1 tri T2 ]]$.
We extend the coercion typing of \tname in \cref{fig:co} with one new rule
\rref*{ct-forall} as shown below:
\[
  \drule{ct-forall}
\]


\paragraph{\tnamee Dynamic Semantics.}


\begin{figure}[t]
  \centering
  \begin{drulepar}[r]{$[[e --> e']]$}{Single-step reduction}{}
    \drule{id}
    \drule{trans}
    \drule{top}
    \drule{topArr}
    \drule{pair}
    \drule{arr}
    \drule{distArr}
    \drule{projl}
    \drule{projr} \and
    \hlmath{\drule{forall}} \and
    \hlmath{\drule{tapp}} \and
    \drule{app}
    \drule{ctxt}
  \end{drulepar}
  \caption{Dynamic semantics of \tnamee}
  \label{fig:red:fi}
\end{figure}


We extend the evaluation context with one new form $[[EE T]]$ for type
applications, as shown in \cref{fig:syntax:fco}. The set of reduction rules for \tnamee in \cref{fig:red:fi}
is a straightforward extension of \tname. We
have a new reduction rule \rref*{r-forall} for the new coercion. This rule might look
strange at first. To explain, let us use our old trick of treating the coercion
$[[\ c]]$ as the term $[[ \f . \ X . c (f X) ]]$, then the application
$[[(\f . \ X . c (f X)) v T ]]$ reduces to $[[ c (v T) ]]$. Also we add the
reduction rule \rref*{r-tapp} for type applications. Now we can show that
\tnamee is type-safe in the usual sense:

\begin{theorem}[Preservation of \tnamee]
  If $[[empty; empty |- e : T]]$ and $[[e --> e']]$, then $[[empty; empty |- e' : T]]$.
\end{theorem}

\begin{theorem}[Progress of \tnamee]
  If $[[empty; empty |- e : T]]$, then either $[[e]]$ is a value, or there exists $[[e']]$ such
  that $[[e --> e']]$.
\end{theorem}


\paragraph{Elaboration.}

We go back to the translation parts in \cref{fig:typing:fi}. The key idea of the
translation remains the same: we translate merges to pairs. For disjoint
quantification and disjoint type applications (\rref{FT-tabs,FT-tapp}), we
translate them to regular universal quantification and type applications,
respectively. For \rref{FT-rcd,FT-proj} we simply erase
the labels and translate the corresponding underlying term. All the remaining
rules are ported from \namee. To conclude, we show an example translation:
\begin{align*}
  & [[ (\X ** nat . (\x . x) : X -> X)  : \ X ** nat . X & nat -> X ]] \\
  \rightsquigarrow & \\
  & [[\ (pp1 -> id)  (\ X . \x . x)]]
\end{align*}

As with \namee, we show two lemmas that relate \fnamee to \tnamee.

\begin{lemma}[Coercions preserve types]
  If $[[A <: B ~~> c]]$, then $[[c |-  |A| tri |B|]]$.
  \label{lemma:sub-correct:fi}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of subtyping.
\end{proof}


\begin{lemma}[Elaboration soundness] We have that:
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of typing.
\end{proof}


\paragraph{Algorithmic subtyping.}



\begin{figure}[t]
  \centering
  \begin{drulepar}[A]{$[[fs |- A <: B ~~> c]]$}{Algorithmic subtyping}{}
    \drule{prim}
    \drule{and}
    \drule{arr}
    \drule{rcd}
    \drule{top} \and
    \hlmath{\drule{forall}} \and
    \hlmath{\drule{var}} \and
    \drule{arrR}
    \drule{rcdR}
    \drule{andROne}
    \drule{andRTwo}
  \end{drulepar}
  \caption{Algorithmic subtyping of \fnamee}
  \label{fig:algo:sub:fi}
\end{figure}

We extend the algorithmic subtyping for \namee with two rules
\rref*{A-forall,A-var}, as shown in \cref{fig:algo:sub:fi}. They are simple
adaptions from their declarative counterparts. We also need to extend the
definition of rigid types to include type variables and disjoint quantification,
shown in \cref{def:rigid:extended}.

\begin{definition}[Rigid types, extended] \label{def:rigid:extended}
  \begin{mathpar}
    [[  pri rigid  ]] \and
    [[ X  rigid ]] \and
    [[ \X ** A . B rigid ]]
  \end{mathpar}
\end{definition}

Finally we show the correctness of the algorithmic subtyping:

\begin{theorem}[Soundness]
  If $[[ fs |- A <: B ~~> c]]$ then $ [[   A <: fs -> B ~~> c  ]]   $.
\end{theorem}

\begin{theorem}[Completeness] \label{thm:complete}
  If $[[A <: B ~~> c]]$ then there exists $[[c']]$ such that $[[ [] |- A <: B ~~> c']]$.
\end{theorem}



% \begin{remark}
%   As already can be seen, one drawback of our algorithmic subtyping is that the
%   size of rules grows exponentially as more constructs are added.
% \end{remark}
