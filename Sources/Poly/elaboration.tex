
\section{Elaboration and Type Safety}
\label{sec:elaboration:fi}



\begin{figure}
  \centering
\begin{tabular}{llll} \toprule
  Types & $[[T]]$ & $\Coloneqq$ & $[[nat]] \mid [[Unit]] \mid [[T1 -> T2]]  \mid [[T1 * T2]] \mid \hlmath{[[X]] } \mid \hlmath{[[\ X . T]]}$\\
  Expressions & $[[e]]$ & $\Coloneqq$ & $[[x]] \mid [[i]] \mid [[unit]] \mid [[\x . e]] \mid [[e1 e2]] \mid [[< e1 , e2>]]  \mid [[c e]] \mid \hlmath{[[\X . e]]} \mid \hlmath{[[ e T ]]}$ \\
  Coercions & $[[c]]$ & $\Coloneqq$ & $[[id]] \mid [[c1 o c2]] \mid [[top]] \mid [[c1 -> c2]] \mid [[< c1 , c2 >]] \mid [[pp1]] \mid [[pp2]] $ \\
  & & $\mid$ & $ [[distArr]] \mid [[topArr]] \mid \hlmath{[[\ c]]} $ \\
  Values & $[[v]]$ & $\Coloneqq$ & $[[i]] \mid [[unit]] \mid [[\x . e]] \mid [[< v1 , v2>]] \mid [[ (c1 -> c2) v ]] \mid [[distArr v]] \mid [[topArr v]] $ \\
  & & $\mid$ & $ \hlmath{[[\c v]]} \mid \hlmath{[[\X . e]]}  $ \\
  Value Context & $[[gg]]$ & $\Coloneqq$ &  $[[empty]] \mid [[gg , x : T]] $ \\
  Type Context & $[[dd]]$ & $\Coloneqq$ &  $[[empty]] \mid [[dd , X ]] $ \\
  Evaluation Context & $[[EE]]$ & $\Coloneqq$ &  $  [[__]] \mid [[EE e]] \mid [[v EE]] \mid [[ < EE , e >  ]] \mid [[ < v , EE > ]] \mid [[ c EE  ]] \mid \hlmath{[[ EE T  ]]}  $ \\ \bottomrule
\end{tabular}
\caption{Syntax of \tnamee}
\label{fig:syntax:fco}
\end{figure}


Like \namee, the operation semantics of \fnamee is given by elaborating into
target expressions. The target calculus \tnamee is the standard call-by-value
System F extended with products and coercions. The syntax of \tnamee is shown in
\cref{fig:syntax:fco}, with the differences from \tname \hll{highlighted}. We naturally
extend the type translation function $| \cdot |$ to cover type variables and
disjoint quantification as shown in \cref{def:type:translate:fi}. For disjoint
quantification, we simply erase the disjointness constraint and translate the
body.

\begin{definition}[Type translation from \fnamee to \tnamee] \label{def:type:translate:fi}
  \begin{align*}
    | [[nat]] | &= [[nat]] \\
    | [[Top]] | &= \langle \rangle \\
    | [[A -> B]]  | &= [[ | A | -> | B |  ]] \\
    | [[ A & B  ]] | &= [[ | A | * | B |  ]] \\
    | [[ X  ]] | &= [[ X ]] \\
    | [[ \X ** A . B ]] | &= [[ \ X . | B | ]]
  \end{align*}
\end{definition}


\paragraph{Coercions and Coercive Subtyping.}

We extend the coercions of \tname with a new coercion form $[[ \ c ]]$, which
express the transformation between two universal quantifiers. Now we go back to
the coercion part in \rref{S-forall}. Since disjointness constraint is erased,
we only need the coercion generated by the subtyping of the bodies $[[B1]]$ and
$[[B2]]$.


\paragraph{\tnamee Static Semantics.}


\begin{figure}
  \centering
  \drules[wfe]{$[[ dd |- gg   ]]$}{Well-formedness of value context}{empty, var}
  \drules[wft]{$[[ dd |- T   ]]$}{Well-formedness of types}{int, var, arrow,prod, all}
  \drules[Ft]{$[[ dd ; gg |- e : T ]]$}{Static semantics}{unit, int, var, abs, app, tabs, tapp, pair, capp}
  \caption{\tnamee static semantics}
  \label{fig:typing:fco}
\end{figure}

\Cref{fig:typing:fco} presents the typing rules of \tnamee. Most of the rules
are quite standard. \Rref{Ft-capp} uses the coercion typing judgment $[[ c |- T1 tri T2 ]]$.
We extend the coercion typing of \tname in \cref{fig:co} with one new rule
\rref*{ct-forall} as shown below:
\[
  \drule{ct-forall}
\]


\paragraph{\tnamee Dynamic Semantics.}

We extend the evaluation context with one new form $[[EE T]]$ for type
applications, as shown in \cref{fig:syntax:fco}. The reduction rules for
coercions are the same as in \cref{fig:coercion_red}, plus one new rule
\rref*{r-forall} as shown below:
\[
  \drule{r-forall}
\]
Also we add the reduction rule for type applications:
\[
  \drule{r-tapp}
\]
The rest of the reduction rules are exactly the same as in \cref{fig:coercion_red}. Now we can show
that \tnamee is type-safe in the usual sense:

\begin{theorem}[Preservation of \tnamee]
  If $[[empty; empty |- e : T]]$ and $[[e --> e']]$, then $[[empty; empty |- e' : T]]$.
\end{theorem}

\begin{theorem}[Progress of \tnamee]
  If $[[empty; empty |- e : T]]$, then either $[[e]]$ is a value, or there exists $[[e']]$ such
  that $[[e --> e']]$.
\end{theorem}


\paragraph{Elaboration.}

We go back to the translation parts in \cref{fig:typing:fi}. The key idea of the
translation remains the same: we translate merges to pairs. For disjoint
quantification and disjoint type applications (\rref{FT-tabs,FT-tapp}), we
translate them to regular universal quantification and type applications,
respectively. For \rref{FT-rcd,FT-proj} we simply erase
the labels and translate the corresponding underlying term. All the remaining
rules are ported from \namee.


As with \namee, we show two lemmas that relate \fnamee to \tnamee.

\begin{lemma}[Coercions preserve types]
  If $[[A <: B ~~> c]]$, then $[[c |-  |A| tri |B|]]$.
  \label{lemma:sub-correct:fi}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of subtyping.
\end{proof}


\begin{lemma}[Elaboration soundness] We have that:
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$, then $[[ |DD| ; |GG| |- e : |A | ]]$.
  \end{itemize}
\end{lemma}
\begin{proof}
  By structural induction on the derivation of typing.
\end{proof}



\paragraph{Algorithmic subtyping.}

The algorithmic subtyping for \fnamee is a straightforward extension of \namee's
algorithmic subtyping, because we can treat $[[ \ X ** A . B ]]$ and $[[X]]$
like $[[nat]]$. \Cref{fig:algo:sub:fi} only shows the extended rules compared
with \cref{fig:algorithm}.

\begin{figure}
  \centering
  \drules[A]{$[[fs |- A <: B ~~> c]]$}{Algorithmic subtyping}{forall,var,rcdVar,rcdAll,andVarOne,andVarTwo,andAllOne,andAllTwo,arrVar,arrAll}
  \caption{Algorithmic subtyping of \fnamee (extended rules)}
  \label{fig:algo:sub:fi}
\end{figure}

% \begin{remark}
%   As already can be seen, one drawback of our algorithmic subtyping is that the
%   size of rules grows exponentially as more constructs are added.
% \end{remark}
