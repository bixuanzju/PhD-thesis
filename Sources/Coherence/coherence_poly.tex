
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Coherence for \fnamee}
\label{chap:coherence:poly}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we extend the canonicity relation introduced in
\cref{chap:coherence:simple} to prove coherence for \fnamee. Firstly in
\cref{sec:para:intuition} we discuss why adding BCD subtyping to disjoint
polymorphism makes establishing coherence even challenging. We then review the
parametric logical relation for System F~\citep{reynolds1983types} in
\cref{sec:para:lr}, and talk about a failed attempt on a natural extension to
deal with disjoint polymorphism in \cref{sec:failed:lr}. The technical
difficulty is \emph{well-foundedness}, stemming from the interaction between
impredicativity and disjointness. Finally in \cref{sec:succeed:lr}, we present
our (predicative) logical relation that is specially crafted to prove coherence
for \fnamee, and allude briefly to a potential solution to lift the
predicativity restriction.


\section{The Challenges}
\label{sec:para:intuition}

To have a better understanding at why adding BCD subtyping to disjoint
polymorphism poses difficulties in terms of proving coherence, let us first
understand how \fname retains coherence. In \fname it is of great importance to
show that type system only produces \emph{well-formed} types. Recall the
well-formedness rule for intersection types (\rref{wf-and}) in
\cref{fig:lambdai}, which has a deep impact on the metatheory. For example, they
need extra effort to prove a (weaker) substitution lemma, and also that
disjointness between two types is preserved after substitution. To understand
why the former is required, consider the judgment $[[ X ** nat |- X & nat ]]$.
The type variable $[[X]]$ cannot be instantiated with arbitrary types, e.g.,
substituting $[[X]]$ with $[[nat]]$ would lead to an ill-formed intersection
type $[[nat & nat]]$. Therefore the range of types is narrowed down to those
that respect the disjointness constraints---we have essentially a weaker
substitution lemma. To motivate the latter, which is closely related to the
former, consider the judgment $[[ X ** nat |- X ** nat ]]$. Obviously $[[X]]$
cannot be instantiated with $[[nat]]$, either. Generally speaking,
substitution-related lemmas are all weakened to account for disjointness
conditions in \fname. All of these contribute to the single most important
theorem: subtyping of \emph{well-formed} types produces \emph{unique} coercions.

However for \fnamee, the well-formedness of intersection types (\rref{swft-and})
in \cref{fig:well-formedness:fi} does not demand a disjointness premise. This
implies that we now have a general substitution lemma, but also that the avenue
taken by \citet{alpuimdisjoint} to prove coherence does not work anymore. In
particular, subtyping does not necessarily produces unique coercions. For example,
consider the possible coercions generated
by $[[ \X ** nat . X & X  <: \X ** nat & nat . X ]]$. Neither of the types
is ``well-formed'' in the sense of \fname. Two possible coercions are
$[[   \f . \X . pp1 (f X)  ]]$ and $[[   \f . \X . pp2 (f X)  ]]$. It is not entirely obvious
that these two are equivalent in some sense.
Moreover, the addition of BCD subtyping aggravates the matter---i.e.,
the subtyping relation becomes even more non-deterministic, producing more syntactically different coercions that are harder
to argue to be equivalent. Clearly a better way to prove coherence is called for!
Parametricity \`a la System F might give us some intuitions, as we will discuss below.


\section{Review of the Parametric Logical Relation}
\label{sec:para:lr}

\begin{figure}[t]
  \centering
  \begin{tabular}{lll}
  $[[(v1 , v2) in V ( X ) with pq ]]$  &$\defeq$ & $ ([[v1]], [[v2]]) \in [[pq]]([[X]])   $ \\
  $[[(v1 , v2) in V ( nat ) with pq ]]$  &$\defeq$ & $\exists [[i]].\, [[v1]] = [[v2]] = [[ii]]$ \\
  $[[(v1 , v2) in V ( T1 -> T2 ) with pq ]]$  & $\defeq$ & $\forall [[(v'1, v'2) in V (T1) with pq  ]].\, [[  (v1 v1' , v2 v2') in E (T2) with pq   ]]$ \\
  $[[(v1 , v2) in V ( T1 * T2 ) with pq ]]$  & $\defeq$ & $[[( pp1 v1, pp1 v2 ) in E (T1) with pq ]]  \land [[ (pp2 v1, pp2 v2) in E (T2) with pq ]]   $ \\
  $[[(v1 , v2) in V ( \X . T ) with pq ]]$  & $\defeq$ & $ \forall [[T1]], [[T2]], [[R]] \subseteq [[T1]] \times [[T2]].\, [[ (v1 T1, v2 T2) in E (T) with pq [X -> R ]     ]]  $ \\ \\
  $[[(e1, e2) in E (T) with pq ]]$ & $\defeq$ & $\exists [[v1]], [[v2]].\, [[e1 -->> v1]] \land [[e2 -->> v2]] \land [[(v1, v2) in V (T) with pq ]]$
  \end{tabular}
  \caption{A logical relation for System F}
  \label{fig:logical:f}
\end{figure}

System F provides a reasoning principle called \emph{relational
  parametricity}~\citep{reynolds1983types} for establishing when two expressions
of the same type have identical behavior. The principle is expressed in terms of
a logical relation. It is well-known that the logical relation of System F
induces the \emph{abstraction theorem} (also called the \emph{parametricity
  theorem}) of \citet{reynolds1983types}, which roughly says that every
well-typed expression behaves the same as itself according to its type. The
stringency of parametricity ensures that a polymorphic type has very few
inhabitants, so few that we can deduce the behavior of a program by just looking
at its type, which \citet{wadler1989theorems} christened \emph{theorems for free}.

Consider an expression $[[e]]$ of type $[[ \X . X -> nat ]]$. The following
``free'' theorem completely determines the behavior of $[[e]]$ and any other
function of the same type---i.e., all expressions with this type have to be constant
functions.

\begin{proposition}[A free theorem of $[[ \X . X -> nat ]]$] \label{thm:free}
  Suppose $[[e]]$ is any expression of type $[[\X . X -> nat]]$. Let $[[T1]]$
  and $[[T2]]$ be arbitrary types. For any $[[v1]]$ of type $[[T1]]$ and
  $[[v2]]$ of type $[[T2]]$, if $[[e T1 v1 -->> v3]]$ and $[[e T2 v2 -->> v4]]$ then $[[v3]] = [[v4]]$.
\end{proposition}


\Cref{fig:logical:f} defines the logical relation for call-by-value System F.
Compared with the logical relation for simple types, it is parameterized by a
relational mapping $[[pq]]$, which plays a central role for type abstractions
and type variables. Intuitively, for two values $[[v1]]$ and $[[v2]]$ of type
$[[\X . T]]$ to behave the same, their instantiations must behave the same.
However, because $[[v1]]$ and $[[v2]]$ do not manipulate the values of type
$[[X]]$, it is not required that they should behave the same at the
\emph{same} instantiation. Indeed, as we saw in \cref{thm:free}, we shall be
able to consider \emph{separately} instances of $[[v1]]$ and $[[v2]]$ by types
$[[T1]]$ and $[[T2]]$, and treat the type variable $[[X]]$ as standing for any
relation $[[R]]$ between $[[T1]]$ and $[[T2]]$. Now it is apparent that the
relational mapping $[[pq]]$ maps each type variable $[[X]]$ to a relation
$[[R]]$ that says how values at type $[[X]]$ should be related. This explains
why for type variables, values of type $[[X]]$ are related according to the
relation associated with $[[X]]$ in the mapping $[[pq]]$.



\section{Impredicativity and Disjointness at Odds}
\label{sec:failed:lr}

Based on the parametric logical relation of System F, it is not hard to come up
with a heterogeneous version, similar to \cref{fig:logical}, but with a
relational mapping.
\begin{align*}
 [[(v1, v2)  in V(A1 -> B1; A2 -> B2) with pq ]] &\defeq \forall [[(v'1, v'2) in V (A1; A2) with pq  ]].\, [[  (v1 v1' , v2 v2') in E (B1 ; B2) with pq   ]] \\
  [[( < v1 , v2 > , v3  )  in V ( A & B ;  C  ) with pq ]]  &\defeq [[ (v1, v3)  in V (A ; C) with pq ]] \land [[ (v2, v3)  in V (B ; C) with pq ]] \\
  [[( v3 , < v1 , v2 >  )  in V ( C ; A & B  ) with pq ]]  &\defeq [[ (v3, v1)  in V (C ; A) with pq ]] \land [[ (v3, v2)  in V (C ; B) with pq ]] \\
  [[(v1, v2)  in V(X; X) with pq ]] &\defeq ([[v1]], [[v2]]) \in [[pq]]([[X]])
\end{align*}
The first three cases do not manipulate $[[pq]]$ and are directly ported from
\cref{fig:logical}. The case for type variables is directly copied from
\cref{fig:logical:f}. For type abstractions, we follow the definition for System
F, but also take care of disjointness constraints, as shown below.
\begin{align*}
  [[(v1, v2)  in V(\X ** A1 . B1; \X ** A2 . B2) with pq ]] &\defeq \forall [[empty |- C1 ** pq(A1 & A2) ]], [[empty |- C2 ** pq(A1 & A2)]], \\
                                                            & \quad [[R]] \subseteq [[C1]] \times [[C2]]. \\
                                                            & \quad [[ ( v1 |C1|, v2 |C2|) in E (B1 ; B2) with pq[X -> R]    ]]
\end{align*}
Compared with parametricity \`a la System F, here we cannot pick arbitrary two types
except those that respect the disjointness constraints, due to the typing rule
for type applications (\rref{FT-tapp}). Let us see an example in action to get a
taste of how this definition works. Suppose $[[e]]$ is any expression
corresponding to type $[[ \X ** bool . \Y ** X . X & Y -> Y & X ]]$, for any
integer $[[v1]]$ and character $[[v2]]$, it can be shown that
\[
  [[e nat char <v1 , v2> -->> <v2 , v1>   ]]
\]
First, we have $[[ (e, e) in E( \X ** bool . \Y ** X . X & Y -> Y & X ) ]]$.
Choose $\mathsf{R}_1 = \{ ([[v1]], [[v1]]) \}$ and $\mathsf{R}_2 = \{ ([[v2]], [[v2]]) \}$.
This is allowed because $[[nat]]$ and $[[char]]$ both respect the
disjointness constraints. Suppose $[[ e nat char -->> v  ]]$ for some $[[v]]$ and we have
\[
  [[(v, v) in V (X & Y -> Y & X) with emp[X -> R1][Y -> R2] ]]
\]
Note that the input $[[  <v1, v2>  ]]$ is related to itself at $[[ X & Y   ]]$
\[
  [[ (<v1, v2>, <v1, v2>) in V (X & Y) with emp[X -> R1][Y -> R2] ]]
\]
So the outputs of $[[v]]$ are related at $[[ Y & X ]]$
\[
  [[ (v <v1, v2>, v <v1, v2>) in E (Y & X) with emp[X -> R1][Y -> R2] ]]
\]
Suppose $[[  v <v1, v2> -->> <v3 , v4>  ]]$, we have
\[
  [[ (<v3, v4>, <v3, v4>) in V (Y & X) with emp[X -> R1][Y -> R2] ]]
\]
We have $([[v3]], [[v3]]) \in \mathsf{R}_2$ and $([[v4]], [[v4]]) \in \mathsf{R}_1$, which means
$[[v3]] = [[v2]]$ and $[[v4]] = [[v1]]$. So we have shown
\[
  [[ e nat char <v1, v2> -->> v <v1, v2> ]] [[-->>]] [[  <v2, v1>  ]]
\]

\paragraph{The Problem with Type Variables.}

Heterogeneity forces us to consider the case for
$\valR{[[X]]}{[[A]]}$ where $[[A]] \neq [[X]]$. A seemingly innocuous definition
is as follows:
\begin{align*}
  [[(v1, v2)  in V(X; A) with pq ]] &\defeq [[ (v1, v2) in V(pq(X); pq(A)) with emp  ]]
\end{align*}
That is, given $[[v1]]$ of type $[[X]]$ and $[[v2]]$ of type $[[A]]$, they are
related at $[[X]]$ and $[[A]]$ if and only if they are related at $[[pq(X)]]$
and $[[pq(A)]]$.
% \footnote{Here we are abusing the notation with the intention
%   that $[[pq(X)]]$ means the assigned type of $[[X]]$ in $[[pq]]$; and
%   $[[pq(A)]]$ means substituting all the variables mentioned in $[[pq]]$ with
%   the corresponding types in $[[A]]$.}
Let us see another example to motivate this definition. Suppose
\[
  [[ee]] = [[\ X ** bool . (\x . x) : X & nat -> X & nat]]
\]
we should expect the following to
hold:\footnote{The reader is advised to try it out in our prototype interpreter.}
\[
  [[ee nat 1 -->> <1 , 1> ]]
\]
It boils down to verifying the following:
\[
  [[  (1 , 1) in V (X ; nat) with pq  ]]
\]
where the mapping $[[pq]]$ maps $[[X]]$ to a relation over integers. If we
replace $[[X]]$ with $[[nat]]$ then the above holds obviously.
Unfortunately, the seemingly innocuous definition for type variables has a serious
issue with impredicativity---in other words, the relation in question is \emph{not well-founded}.
We could pick a bad instantiation to make the relation ``go
into a loop''. For example, suppose $[[pq]]$ only contains a mapping from $[[X]]$ to
$[[\X . \Y . Y]]$, we then have the following infinite chain of equational reasoning:
\[
 \valR{[[X]]}{[[\Y . Y]]}_{[[pq]]} = \valR{[[\X . \Y . Y]]}{[[\Y. Y]]}_{[[emp]]} = \eeR{[[\Y . Y]]}{[[ X ]]}_{[[pq]]} = \valR{[[\Y . Y]]}{[[ X ]]}_{[[pq]]} = \dots
\]
The culprit is the polymorphic instantiation $[[\X . \Y . Y]]$, which is larger
than $[[\Y . Y]]$. This is the exact circumstance where in \cref{fig:logical:f}
substitution is deliberately avoided for type abstractions.

\section{Predicative Logical Relation}
\label{sec:succeed:lr}

In light of the fact that substitution in the logical relation seems unavoidable
in our setting, and that impredicativity conflicts with substitution, we turn
to, for the lack of a better logical relation, \emph{predicativity}. The
restriction to predicativity, though reducing the expressiveness in theory, does
not cost much in practice. Languages based on the Hindleyâ€“Milner type
system~\citep{milner1978theory, hindley1969principal}, such as Haskell and ML,
have such restriction. We also plan to study a variant of \fnamee with implicit polymorphism,
as briefly discussed in \cref{sec:implicit}.

\begin{figure}
  \centering
  \begin{small}
  \begin{tabular}{lll}
  $[[(v1 , v2) in V ( nat ; nat ) ]]$  & $\defeq$ & $\exists [[i]].\, [[v1]] = [[v2]] = [[ii]]$ \\
  $[[(v1, v2) in V ( {l : A}  ; {l : B} ) ]]$ & $\defeq$ & $[[ (v1, v2) in V ( A ; B ) ]]$\\
  $[[(v1 , v2) in V ( A1 -> B1 ; A2 -> B2 ) ]]$  & $\defeq$ & $\forall [[(v2' , v1') in V ( A2 ; A1 ) ]].\, [[ (v1 v1' , v2 v2') in E ( B1 ; B2 ) ]]$ \\
    $\hlmath{[[(v1, v2)  in V ( \ X ** A1 . B1; \ X ** A2 . B2 ) ]]}$  &$\defeq$ & $\hlmath{\forall [[empty |- t ** A1 & A2 ]].}$ \\
                                       && $\hlmath{[[  (v1 |t| , v2 |t|) in E ( [t / X] B1 ; [t / X] B2) ]]}$ \\
  $[[( < v1 , v2 > , v3  )  in V ( A & B ;  C  ) ]]$  & $\defeq$ & $[[ (v1, v3)  in V (A ; C) ]] \land [[ (v2, v3)  in V (B ; C) ]]$  \\
  $[[( v3 , < v1 , v2 >  )  in V ( C; A & B  ) ]]$  & $\defeq$ & $[[ (v3, v1)  in V (C ; A) ]] \land [[ (v3, v2)  in V (C ; B) ]]$  \\
  $[[(v1 , v2) in V (A; B) ]]$  & $\defeq$ & $\mathsf{true} \quad \text{otherwise}$ \\ \\
    $[[(e1, e2) in E (A; B)]]$ & $\defeq$ & $\exists [[v1]], [[v2]].\, [[e1 -->> v1]] \land [[e2 -->> v2]] \ \land $ \\
                                       & & $[[(v1, v2) in V (A; B)]]$
  \end{tabular}
  \end{small}
  \caption{\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L105}{\leftpointright} The canonicity relation for \fnamee}
  \label{fig:logical:fi}
\end{figure}

Substitution with predicative instantiations does not prevent well-foundedness.
\Cref{fig:logical:fi} presents the logical relation for \fnamee.\footnote{In the
  Coq formalization, due to some technical difficulties, it contains one
  ``Admit'' about well-foundedness, for which we provide a manual proof
  (\cref{lemma:well-founded}).} We extend the canonicity relation in
\cref{fig:logical} with a new clause (highlighted) for disjoint quantification.
Notice that it does not quantify over arbitrary relations, which means that our
logical relation \emph{does not} imply parametricity, and in particular,
\cref{thm:free} is impossible to prove using our logical relation. However, it
suffices for our purposes to prove coherence. Also notice that we directly
substitute $[[X]]$ with $[[t]]$ in both $[[B1]]$ and $[[B2]]$. It can be shown
that the relation is well-founded.

\begin{lemma}[Well-foundedness] \label{lemma:well-founded}
  The logical relation as defined in \cref{fig:logical:fi} is well-founded.
\end{lemma}
\begin{proof}
  Let $| \cdot |_{\forall}$ and $| \cdot |_s$ denote the number of
  $\forall$-quantifies and the size of types, respectively. The following
  measure suffices to prove well-foundedness:
  \[
\langle | \cdot |_{\forall} ,  | \cdot |_s   \rangle
  \]
  where $\langle \dots \rangle$ denotes lexicographic order. We can verify that
  for the clause of disjoint quantification, the number of $\forall$-quantifies
  decreases, because the monotype $[[t]]$ does not contain $\forall$-quantifies.
  For the other clauses, either the measure of $| \cdot |_{\forall}$ decreases,
  or it remains the same but the measure of $| \cdot |_s$ decreases.
\end{proof}


Another noticeable thing is that in the value relation $ \valR{[[A]]}{[[B]]} $
(and $\eeR{[[A]]}{[[B]]} $), we keep the invariant that $[[A]]$ and $[[B]]$
are closed types. This is why we do not need to consider type variables in the
logical relation, which simplifies the proof a lot. We show that the logical
relation is symmetric.


\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L817}{\leftpointright} Symmetry of logical relation]
  If $[[ (v1, v2) in V ( A ; B ) ]]$ then $[[ (v2, v1) in V ( B ; A ) ]]$.
\end{lemma}
\begin{proof}
  Symmetry of \cref{fig:logical} is trivial. For \cref{fig:logical:fi}, the
  proof proceeds by first induction on $ | [[A]] |_{\forall} $ then simultaneous
  induction on the structures of $[[A]]$ and $[[B]]$.
\end{proof}

\section{Establishing Coherence}

We are now ready to prove coherence for \fnamee. The proof of coherence
basically follows that in \cref{chap:coherence:simple}. We first give the
interpretations of type and value contexts ($[[p]]$ is a mapping from type
variables to monotypes).

\begin{definition}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/Infrastructure.v\#L2022}{\leftpointright} Interpretation of type contexts]
  \begin{mathpar}
    \ottaltinferrule{}{}{  }{ [[emp in empty]] } \and
    \ottaltinferrule{}{}{ [[p in DD]] \\ [[empty |- t ** p(B)]] \\  }{ [[p [ X -> t ] in DD , X ** B]]  }
  \end{mathpar}
\end{definition}


\begin{definition}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L166}{\leftpointright} Interpretation of value contexts]
  \begin{mathpar}
    \ottaltinferrule{}{}{  }{ [[(emp, emp) in empty with p ]]  } \and
    \ottaltinferrule{}{}{ [[(g1, g2) in GG with p ]] \\ [[(v1, v2) in V (p(A)) ]] }{ [[(g1 [ x -> v1 ] , g2 [ x -> v2 ]  )  in GG , x : A with p ]] }
  \end{mathpar}
\end{definition}


\paragraph{Logical Equivalence.}

Logical equivalence is defined in terms of logical relation by considering all possible interpretations of
free type and term variables.

\begin{definition}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L180}{\leftpointright} Logical equivalence]
  \begin{align*}
    [[DD ; GG |- e1 == e2 : A ; B]]  & \defeq  [[|DD| ; |GG| |- e1 : |A|]] \land [[ |DD | ; |GG| |- e2 : | B | ]] \ \land \\
                                       & \qquad (\forall [[p]], [[g1]], [[g2]]. \ ([[p in DD]] \land [[(g1, g2) in GG with p ]]) \\
                                       & \qquad \Longrightarrow [[(g1 (p1 (e1)), g2 (p2 (e2)))  in E (p(A) ; p(B)) ]])
  \end{align*}
\end{definition}


\paragraph{Contextual Equivalence.}

\begin{figure}
  \centering
\begin{tabular}{llll}\toprule
  \tnamee contexts & $[[cc]]$ & $\Coloneqq$ &  $[[__]] \mid [[\ x . cc]] \mid \hlmath{[[\ X . cc]]}  \mid \hlmath{[[ cc T  ]]} \mid [[cc e]] \mid [[e cc]] \mid [[< cc , e>]] \mid [[<e , cc>]] \mid [[c cc]] $ \\
  \fnamee contexts & $[[CC]]$ & $\Coloneqq$ &  $[[__]] \mid [[\ x . CC]] \mid \hlmath{[[\ X ** A. CC]]} \mid \hlmath{[[ CC A  ]]} \mid [[CC ee]] \mid [[ee CC]] \mid [[ CC ,, ee  ]] \mid [[ ee ,, CC  ]]  $ \\
  & & $\mid$ & $[[ { l = CC}  ]]  \mid [[ CC . l]]   $  \\ \bottomrule
\end{tabular}
  \caption{Expression contexts of \tnamee and \fnamee}
  \label{fig:contexts:fi}
\end{figure}



\begin{figure}
  \centering
\drules[FCTyp]{$[[ CC : ( DD ; GG => A ) ~> ( DD' ; GG' => B ) ~~> cc ]]$}{Context typing I}{emptyOne, appLOne, appROne, mergeLOne, mergeROne, rcdOne, projOne, annoOne, tabsOne, tappOne}
\caption{\fnamee context typing (excerpt)}
\label{fig:fctyp}
\end{figure}


To define the contextual equivalence, we must define the expression contexts for
\fnamee and \tnamee, which are shown in \cref{fig:contexts:fi} (highlighted for
the differences from \namee contexts). The typing judgment of
\fnamee contexts has 4 different forms:
\begin{mathpar}
  [[CC : (DD; GG => A) ~> (DD'; GG' => A') ~~> cc]] \and
  [[CC : (DD; GG <= A) ~> (DD'; GG' => A') ~~> cc]] \and
  [[CC : (DD; GG => A) ~> (DD'; GG' <= A') ~~> cc]] \and
  [[CC : (DD; GG <= A) ~> (DD'; GG' <= A') ~~> cc]]
\end{mathpar}
\Cref{fig:fctyp} shows one form of rules. The full typing rules appear in \cref{appendix:fi}.
Now we may give the definition of contextual equivalence for \fname as follows:

\begin{definition}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/Compatibility.v\#L471}{\leftpointright} \fnamee Contextual Equivalence]
  \begin{align*}
    [[DD ; GG |- ee1 ~= ee2 : A]]  & \defeq \forall [[e1]], [[e2]].\  [[DD ; GG |- ee1 => A ~~> e1]] \land [[DD ; GG |- ee2 => A ~~> e2]] \ \land   \\
                                     & \qquad (\forall [[C]], [[cc]].\ [[CC : (DD; GG => A) ~> (empty ; empty => nat) ~~> cc]]   \\
                                     & \qquad \Longrightarrow \kleq{[[cc{e1}]]}{[[cc{e2}]]})
  \end{align*}
\end{definition}


The connection between disjointness and the value relation becomes a bit
complicated due to the addition of type variables. We first prove that disjoint
values of monotypes are related.


\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L843}{\leftpointright} Disjoint values of monotypes are related] \label{lemma:disjoint:mono}
  If $[[empty |- t1 ** t2]]$,
  $[[  empty ; empty |-  v1 : |t1|  ]]$ and
  $[[  empty ; empty |-  v2 : |t2|  ]]$
  then $[[   (v1, v2) in V ( t1 ; t2  )    ]]$.
\end{lemma}
\begin{proof}
  By simultaneous induction on $[[t1]]$ and $[[t2]]$.
\end{proof}

Then we can prove a more general lemma.

\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L1120}{\leftpointright} Disjoint values are related]
  If $[[DD |- A ** B]]$, $[[ p in DD  ]]$, $[[  empty ; empty |-  v1 : |p (A)|  ]]$ and $[[  empty ; empty |-  v2 : |p (B)|  ]]$
  then $[[   (v1, v2) in V ( p(A) ; p(B)  )    ]]$.
\end{lemma}
\begin{proof}
  By induction on the derivation of disjointness. The most interesting case is the variable rule:
  \[
    \drule{FD-tvarL}
  \]
  By the definition of $[[p]]$, we know $[[p(X)]]$ is a monotype. If $[[B]]$ is
  a polytype, then it follows easily from the definition of logical relation. If
  $[[B]]$ is also a monotype, we know $[[p(X)]]$ and $[[p(A)]]$ are disjoint by
  definition. Then by \cref{lemma:covariance:disjoint} and $[[A <: B]]$,
  we have $[[p(X)]]$ and $[[p(B)]]$ are also disjoint. Finally we apply
  \cref{lemma:disjoint:mono}.
\end{proof}


Next up are the compatibility lemmas. They are essentially the same as in
\cref{chap:coherence:simple}. So we skip them and state the last two important
theorems without giving proofs. The proofs have mostly the same structures as in the
simply-typed case, but with more cases. The interested reader can refer to our
Coq formalization.

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/Compatibility.v\#L142}{\leftpointright} Fundamental Property] We have that:
  \begin{itemize}
  \item If $[[DD; GG |- ee => A ~~> e]]$ and $[[DD; GG |- ee => A ~~> e']]$, then $[[DD; GG |- e == e' : A ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$ and $[[DD ; GG |- ee <= A ~~> e']]$, then $[[DD; GG |- e == e' : A ]]$.
  \end{itemize}
\end{theorem}

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/Compatibility.v\#L357}{\leftpointright} Congruence]
 If $[[CC : (DD ; GG dir A) ~> (DD' ; GG' dir' A') ~~> cc]]$, $[[DD ; GG |- ee1 dir A ~~> e1]]$, $[[DD ; GG |- ee2 dir A ~~> e2]]$
 and $[[DD ; GG |- e1 == e2 : A ]]$, then $[[DD' ; GG' |- cc{e1} == cc{e2} : A']]$.
\end{theorem}

Finally \fnamee is coherent.

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/Compatibility.v\#L493}{\leftpointright} Coherence of \fnamee] \label{thm:coherence:fi}
  We have that
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ]]$ then $[[DD ; GG |- ee ~= ee : A]]$.
  \item If $[[DD ; GG |- ee <= A ]]$ then $[[DD ; GG |- ee ~= ee : A]]$.
  \end{itemize}
\end{theorem}


\paragraph{Final remarks.}

It would be interesting to study parametricity of \fnamee. As we have seen, it
is not obvious how to extend the parametric logical relation as defined in
\cref{fig:logical:f} to account for disjointness, and avoid potential
circularity due to impredicativity. A possible solution is to use step-indexed
logical relations. We have yet investigated further on that direction.

% Local Variables:
% TeX-master: "../../Thesis"
% org-ref-default-bibliography: ../../Thesis.bib
% End: