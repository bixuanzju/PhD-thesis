
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Coherence for \fnamee}
\label{chap:coherence:poly}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we extend the proof technique introduced in
\cref{chap:coherence:simple} to prove coherence for \fnamee. Firstly we review
the parametric logical relation for System F~\citep{reynolds1983types} in
\cref{sec:para:lr}. We then talk about a failed attempt on a natural extension
to deal with disjoint intersection types in \cref{sec:failed:lr}. The technical
difficulty is \textit{well-foundedness}, stemming from the interaction between
impredicativity and disjointness. Finally in \cref{sec:succeed:lr}, we present
our (predicative) logical relation that is specially crafted to prove coherence
for \fnamee, and talk about a potential solution to lift the predicativity
restriction.


\section{Review of the Parametric Logical Relation}
\label{sec:para:lr}

\begin{figure}[t]
  \centering
  \begin{tabular}{lll}
  $[[(v1 , v2) in V ( X ) with pq ]]$  &$\defeq$ & $ ([[v1]], [[v2]]) \in [[pq]]([[X]])   $ \\
  $[[(v1 , v2) in V ( nat ) with pq ]]$  &$\defeq$ & $\exists [[i]].\, [[v1]] = [[v2]] = [[ii]]$ \\
  $[[(v1 , v2) in V ( T1 -> T2 ) with pq ]]$  & $\defeq$ & $\forall [[(v'1, v'2) in V (T1) with pq  ]].\, [[  (v1 v1' , v2 v2') in E (T2) with pq   ]]$ \\
  $[[(v1 , v2) in V ( T1 * T2 ) with pq ]]$  & $\defeq$ & $[[( pp1 v1, pp1 v2 ) in E (T1) with pq ]]  \land [[ (pp2 v1, pp2 v2) in E (T2) with pq ]]   $ \\
  $[[(v1 , v2) in V ( \X . T ) with pq ]]$  & $\defeq$ & $ \forall [[T1]], [[T2]], [[R]] \subseteq [[T1]] \times [[T2]].\, [[ (v1 T1, v2 T2) in E (T) with pq [X -> R ]     ]]  $ \\ \\
  $[[(e1, e2) in E (T) with pq ]]$ & $\defeq$ & $\exists [[v1]], [[v2]].\, [[e1 -->> v1]] \land [[e2 -->> v2]] \land [[(v1, v2) in V (T) with pq ]]$
  \end{tabular}
  \caption{A logical relation for System F}
  \label{fig:logical:f}
\end{figure}

System F provides a reasoning principle called \textit{relational
  parametricity}~\citep{reynolds1983types} for establishing when two expressions
of the same type have identical behavior. The principle is expressed in terms of
a logical relation. It is well-known that the logical relation of System F
induces the \textit{abstraction theorem} (also called the \textit{parametricity
  theorem}) of \citet{reynolds1983types}, which roughly says that every
well-typed expression behaves the same as itself according to its type. The
stringency of parametricity ensures that a polymorphic type has very few
inhabitants, so few that we can deduce the behavior of a program by just looking
at its type, which \citet{wadler1989theorems} christened \textit{theorems for free}.

Consider an expression $[[e]]$ of type $[[ \X . X -> nat ]]$. The following
``free'' theorem completely determines the behavior of $[[e]]$ and any other
function of the same type---i.e., all expressions with this type have to be constant
functions.

\begin{theorem}[A free theorem of $[[ \X . X -> nat ]]$] \label{thm:free}
  Suppose $[[e]]$ is any expression of type $[[\X . X -> nat]]$. Let $[[T1]]$
  and $[[T2]]$ be arbitrary types. For any $[[v1]]$ of type $[[T1]]$ and
  $[[v2]]$ of type $[[T2]]$, if $[[e T1 v1 -->> v3]]$ and $[[e T2 v2 -->> v4]]$ then $[[v3]] = [[v4]]$.
\end{theorem}


\Cref{fig:logical:f} defines the logical relation for call-by-value System F.
Compared with the logical relation for simple types, it is parameterized by a
relational mapping $[[pq]]$, which plays a central role for type abstractions
and type variables. Intuitively, for two values $[[v1]]$ and $[[v2]]$ of type
$[[\X . T]]$ to behave the same, their instantiations must behave the same.
However, because $[[v1]]$ and $[[v2]]$ do not manipulate the values of type
$[[X]]$, it is not required that they should behave the same at the
\textit{same} instantiation. Indeed, as we saw in \cref{thm:free}, we shall be
able to consider \textit{separately} instances of $[[v1]]$ and $[[v2]]$ by types
$[[T1]]$ and $[[T2]]$, and treat the type variable $[[X]]$ as standing for any
relation $[[R]]$ between $[[T1]]$ and $[[T2]]$. Now it is apparent that the
relational mapping $[[pq]]$ maps each type variable $[[X]]$ to a relation
$[[R]]$ that says how values at type $[[X]]$ should be related. This explains
why for type variables, values of type $[[X]]$ are related according to the
relation associated with $[[X]]$ in the mapping $[[pq]]$.



\section{Impredicativity and Disjointness at Odds}
\label{sec:failed:lr}

Based on the parametric logical relation of System F, it is not hard to come up
with a heterogeneous version, similar to \cref{fig:logical}, but with a
relational mapping.
\begin{align*}
 [[(v1, v2)  in V(A1 -> B1; A2 -> B2) with pq ]] &\defeq \forall [[(v'1, v'2) in V (A1; A2) with pq  ]].\, [[  (v1 v1' , v2 v2') in E (B1 ; B2) with pq   ]] \\
  [[( < v1 , v2 > , v3  )  in V ( A & B ;  C  ) with pq ]]  &\defeq [[ (v1, v3)  in V (A ; C) with pq ]] \land [[ (v2, v3)  in V (B ; C) with pq ]] \\
  [[( v3 , < v1 , v2 >  )  in V ( C ; A & B  ) with pq ]]  &\defeq [[ (v3, v1)  in V (C ; A) with pq ]] \land [[ (v3, v2)  in V (C ; B) with pq ]] \\
  [[(v1, v2)  in V(X; X) with pq ]] &\defeq ([[v1]], [[v2]]) \in [[pq]]([[X]])
\end{align*}
The first three cases do not manipulate $[[pq]]$ and are directly ported from
\cref{fig:logical}. The case for type variables is directly copied from
\cref{fig:logical:f}. For type abstractions, we follow the definition for System
F, but also take care of disjointness constraints, as shown below.
\begin{align*}
  [[(v1, v2)  in V(\X ** A1 . B1; \X ** A2 . B2) with pq ]] &\defeq \forall [[empty |- C1 ** pq(A1 & A2) ]], [[empty |- C2 ** pq(A1 & A2)]], \\
                                                            & \quad [[R]] \subseteq [[C1]] \times [[C2]]. \\
                                                            & \quad [[ ( v1 |C1|, v2 |C2|) in E (B1 ; B2) with pq[X -> R]    ]]
\end{align*}
Compared with the one for System F, here we cannot pick arbitrary two types
except those that respect the disjointness constraints, due to the typing rule
for type applications (\rref{FT-tapp}). Let us see an example in action to get a
taste of how this definition works. Suppose $[[e]]$ is any expression
corresponding to type $[[ \X ** bool . \Y ** X . X & Y -> Y & X ]]$, for any
integer $[[v1]]$ and character $[[v2]]$, it can be shown that
\[
  [[e nat char <v1 , v2> -->> <v2 , v1>   ]]
\]
First, we have $[[ (e, e) in E( \X ** bool . \Y ** X . X & Y -> Y & X ) ]]$.
Choose $\mathsf{R}_1 = \{ ([[v1]], [[v1]]) \}$ and $\mathsf{R}_2 = \{ ([[v2]], [[v2]]) \}$.
This is allowed because $[[nat]]$ and $[[char]]$ both respect the
disjointness constraints. Suppose $[[ e nat char -->> v  ]]$ for some $[[v]]$ and we have
\[
  [[(v, v) in V (X & Y -> Y & X) with emp[X -> R1][Y -> R2] ]]
\]
Note that the input $[[  <v1, v2>  ]]$ is related to itself at $[[ X & Y   ]]$
\[
  [[ (<v1, v2>, <v1, v2>) in V (X & Y) with emp[X -> R1][Y -> R2] ]]
\]
So the outputs of $[[v]]$ are related at $[[ Y & X ]]$
\[
  [[ (v <v1, v2>, v <v1, v2>) in E (Y & X) with emp[X -> R1][Y -> R2] ]]
\]
Suppose $[[  v <v1, v2> -->> <v3 , v4>  ]]$, we have
\[
  [[ (<v3, v4>, <v3, v4>) in V (Y & X) with emp[X -> R1][Y -> R2] ]]
\]
We have $([[v3]], [[v3]]) \in \mathsf{R}_2$ and $([[v4]], [[v4]]) \in \mathsf{R}_1$, which means
$[[v3]] = [[v2]]$ and $[[v4]] = [[v1]]$. So we have shown
\[
  [[ e nat char <v1, v2> -->> v <v1, v2> ]] [[-->>]] [[  <v2, v1>  ]]
\]

Heterogeneity forces us to consider the case for
$\valR{[[X]]}{[[A]]}$ where $[[A]] \neq [[X]]$. A seemingly innocuous definition
is as follows:
\begin{align*}
  [[(v1, v2)  in V(X; A) with pq ]] &\defeq [[ (v1, v2) in V(pq(X); pq(A)) with emp  ]]
\end{align*}
That is, given $[[v1]]$ of type $[[X]]$ and $[[v2]]$ of type $[[A]]$, they are
related at $[[X]]$ and $[[A]]$ if and only if they are related at $[[pq(X)]]$
and $[[pq(A)]]$.
% \footnote{Here we are abusing the notation with the intention
%   that $[[pq(X)]]$ means the assigned type of $[[X]]$ in $[[pq]]$; and
%   $[[pq(A)]]$ means substituting all the variables mentioned in $[[pq]]$ with
%   the corresponding types in $[[A]]$.}
Let us see another example to motivate this definition. Suppose
\[
  [[ee]] = [[\ X ** bool . (\x . x) : X & nat -> X & nat]]
\]
we should expect the following to
hold:\footnote{The reader is advised to try it out in our prototype interpreter.}
\[
  [[ee nat 1 -->> <1 , 1> ]]
\]
It boils down to verifying the following:
\[
  [[  (1 , 1) in V (X ; nat) with pq  ]]
\]
where the mapping $[[pq]]$ maps $[[X]]$ to a relation over integers. If we
replace $[[X]]$ with $[[nat]]$ then the above holds obviously.


Unfortunately, the seemingly innocuous definition for type variables has a serious
issue with impredicativity---in other words, the relation in question is \textit{not well-founded}.
We could pick a bad instantiation to make the relation ``go
into a loop''. For example, suppose $[[pq]]$ only contains a mapping from $[[X]]$ to
$[[\X . \Y . Y]]$, we then have the following infinite chain of equational reasoning:
\[
 \valR{[[X]]}{[[\Y . Y]]}_{[[pq]]} = \valR{[[\X . \Y . Y]]}{[[\Y. Y]]}_{[[emp]]} = \eeR{[[\Y . Y]]}{[[ X ]]}_{[[pq]]} = \valR{[[\Y . Y]]}{[[ X ]]}_{[[pq]]} = \dots
\]
The culprit is the polymorphic instantiation $[[\X . \Y . Y]]$, which is larger
than $[[\Y . Y]]$. This is the exact circumstance where in \cref{fig:logical:f}
substitution is deliberately avoided for type abstractions.

\section{Predicative Logical Relation}
\label{sec:succeed:lr}

In light of the fact that substitution in the logical relation seems unavoidable
in our setting, and that impredicativity conflicts with substitution, we turn
to, for the lack of a better logical relation, \textit{predicativity}. The
restriction to predicativity, though reducing the expressiveness in theory, does
not cost much in practice. Languages based on the Hindleyâ€“Milner type
system~\citep{milner1978theory, hindley1969principal}, such as Haskell and ML,
have such restriction. We also plan to study a variant of \fnamee with implicit polymorphism,
as briefly discussed in \cref{sec:implicit}.

\begin{figure}
  \centering
  \begin{small}
  \begin{tabular}{lll}
  $[[(v1 , v2) in V ( nat ; nat ) ]]$  & $\defeq$ & $\exists [[i]].\, [[v1]] = [[v2]] = [[ii]]$ \\
  $[[(v1, v2) in V ( {l : A}  ; {l : B} ) ]]$ & $\defeq$ & $[[ (v1, v2) in V ( A ; B ) ]]$\\
  $[[(v1 , v2) in V ( A1 -> B1 ; A2 -> B2 ) ]]$  & $\defeq$ & $\forall [[(v2' , v1') in V ( A2 ; A1 ) ]].\, [[ (v1 v1' , v2 v2') in E ( B1 ; B2 ) ]]$ \\
    $\hlmath{[[(v1, v2)  in V ( \ X ** A1 . B1; \ X ** A2 . B2 ) ]]}$  &$\defeq$ & $\hlmath{\forall [[empty |- t ** A1 & A2 ]].}$ \\
                                       && $\hlmath{[[  (v1 |t| , v2 |t|) in E ( [t / X] B1 ; [t / X] B2) ]]}$ \\
  $[[( < v1 , v2 > , v3  )  in V ( A & B ;  C  ) ]]$  & $\defeq$ & $[[ (v1, v3)  in V (A ; C) ]] \land [[ (v2, v3)  in V (B ; C) ]]$  \\
  $[[( v3 , < v1 , v2 >  )  in V ( C; A & B  ) ]]$  & $\defeq$ & $[[ (v3, v1)  in V (C ; A) ]] \land [[ (v3, v2)  in V (C ; B) ]]$  \\
  $[[(v1 , v2) in V (A; B) ]]$  & $\defeq$ & $\mathsf{true} \quad \text{otherwise}$ \\ \\
    $[[(e1, e2) in E (A; B)]]$ & $\defeq$ & $\exists [[v1]], [[v2]].\, [[e1 -->> v1]] \land [[e2 -->> v2]] \ \land $ \\
                                       & & $[[(v1, v2) in V (A; B)]]$
  \end{tabular}
  \end{small}
  \caption{Logical relation for \fnamee}
  \label{fig:logical:fi}
\end{figure}

Substitution with predicative instantiations does not prevent well-foundedness.
\Cref{fig:logical:fi} presents the logical relation for \fnamee. We extend the
logical relation in \cref{fig:logical} with a new clause (highlighted) for
disjoint quantification. Notice that it does not quantify over arbitrary
relations, which means that our logical relation \textit{does not} imply
parametricity, and in particular, \cref{thm:free} is impossible to prove using
our logical relation. However, it suffices for our purposes to prove coherence.
Also notice that we directly substitute $[[X]]$ with $[[t]]$ in both $[[B1]]$
and $[[B2]]$. It can be shown that the relation is well-founded.

\begin{lemma}[Well-foundedness]
  The logical relation as defined in \cref{fig:logical:fi} is well-founded.
\end{lemma}
\begin{proof}
  Let $| \cdot |_{\forall}$ and $| \cdot |_s$ denote the number of
  $\forall$-quantifies and the size of types, respectively. The following
  measure suffices to prove well-foundedness:
  \[
\langle | \cdot |_{\forall} ,  | \cdot |_s   \rangle
  \]
  where $\langle \dots \rangle$ denotes lexicographic order. We can verify that
  for the clause of disjoint quantification, the number of $\forall$-quantifies
  decreases, because the monotype $[[t]]$ does not contain $\forall$-quantifies.
  For the other clauses, either the measure of $| \cdot |_{\forall}$ decreases,
  or it remains the same but the measure of $| \cdot |_s$ decreases.
\end{proof}


Another noticeable thing is that in the value relation $ \valR{[[A]]}{[[B]]} $
(and $\eeR{[[A]]}{[[B]]} $), we keep the invariant that $[[A]]$ and $[[B]]$
are closed types. This is why we do not need to consider type variables in the
logical relation, which simplifies the proof a lot. We show that the logical
relation is symmetric.


\begin{lemma}[Symmetry of logical relation]
  If $[[ (v1, v2) in V ( A ; B ) ]]$ then $[[ (v2, v1) in V ( B ; A ) ]]$.
\end{lemma}
\begin{proof}
  Symmetry of \cref{fig:logical} is trivial. For \cref{fig:logical:fi}, the
  proof proceeds by first induction on $ | [[A]] |_{\forall} $ then simultaneous
  induction on the structures of $[[A]]$ and $[[B]]$.
\end{proof}

\section{Establishing Coherence}

We are now ready to prove coherence for \fnamee. The proof of coherence
basically follows that in \cref{chap:coherence:simple}. We first give the
interpretations of type and value contexts ($[[p]]$ is a mapping from type
variables to monotypes).

\begin{definition}[Interpretation of type contexts]
  \begin{mathpar}
    \ottaltinferrule{}{}{  }{ [[emp in empty]] } \and
    \ottaltinferrule{}{}{ [[p in DD]] \\ [[empty |- t ** p(B)]] \\  }{ [[p [ X -> t ] in DD , X ** B]]  }
  \end{mathpar}
\end{definition}


\begin{definition}[Interpretation of value contexts]
  \begin{mathpar}
    \ottaltinferrule{}{}{  }{ [[(emp, emp) in empty with p ]]  } \and
    \ottaltinferrule{}{}{ [[(g1, g2) in GG with p ]] \\ [[(v1, v2) in V (p(A)) ]] }{ [[(g1 [ x -> v1 ] , g2 [ x -> v2 ]  )  in GG , x : A with p ]] }
  \end{mathpar}
\end{definition}


\paragraph{Logical Equivalence.}

Logical equivalence is defined in terms of logical relation by considering all possible interpretations of
free type and term variables.

\begin{definition}[Logical equivalence]
  \begin{align*}
    [[DD ; GG |- e1 == e2 : A ; B]]  & \defeq  [[|DD| ; |GG| |- e1 : |A|]] \land [[ |DD | ; |GG| |- e2 : | B | ]] \ \land \\
                                       & \qquad (\forall [[p]], [[g1]], [[g2]]. \ ([[p in DD]] \land [[(g1, g2) in GG with p ]]) \\
                                       & \qquad \Longrightarrow [[(g1 (p1 (e1)), g2 (p2 (e2)))  in E (p(A) ; p(B)) ]])
  \end{align*}
\end{definition}


\paragraph{Contextual Equivalence.}

\begin{figure}
  \centering
\begin{tabular}{llll}\toprule
  \tnamee contexts & $[[cc]]$ & $\Coloneqq$ &  $[[__]] \mid [[\ x . cc]] \mid \hlmath{[[\ X . cc]]}  \mid \hlmath{[[ cc T  ]]} \mid [[cc e]] \mid [[e cc]] \mid [[< cc , e>]] \mid [[<e , cc>]] \mid [[c cc]] $ \\
  \fnamee contexts & $[[CC]]$ & $\Coloneqq$ &  $[[__]] \mid [[\ x . CC]] \mid \hlmath{[[\ X ** A. CC]]} \mid \hlmath{[[ CC A  ]]} \mid [[CC ee]] \mid [[ee CC]] \mid [[ CC ,, ee  ]] \mid [[ ee ,, CC  ]]  $ \\
  & & $\mid$ & $[[ { l = CC}  ]]  \mid [[ CC . l]]   $  \\ \bottomrule
\end{tabular}
  \caption{Expression contexts of \tnamee and \fnamee}
  \label{fig:contexts:fi}
\end{figure}


To define the contextual equivalence, we must define the expression contexts for
\fnamee and \tnamee, which are shown in \cref{fig:contexts:fi} (highlighted for
the differences from \namee contexts). The typing judgment of
\fnamee contexts has 4 different forms:
\begin{mathpar}
  [[CC : (DD; GG => A) ~> (DD'; GG' => A') ~~> cc]] \and
  [[CC : (DD; GG <= A) ~> (DD'; GG' => A') ~~> cc]] \and
  [[CC : (DD; GG => A) ~> (DD'; GG' <= A') ~~> cc]] \and
  [[CC : (DD; GG <= A) ~> (DD'; GG' <= A') ~~> cc]]
\end{mathpar}
The full typing rules are similar to \cref{fig:ctyp} and appear in \cref{appendix:fi}.
Now we may give the definition of contextual equivalence for \fname as follows:

\begin{definition}[\fnamee Contextual Equivalence]
  \begin{align*}
    [[DD ; GG |- ee1 ~= ee2 : A]]  & \defeq \forall [[e1]], [[e2]].\  [[DD ; GG |- ee1 => A ~~> e1]] \land [[DD ; GG |- ee2 => A ~~> e2]] \ \land   \\
                                     & \qquad (\forall [[C]], [[cc]].\ [[CC : (DD; GG => A) ~> (empty ; empty => nat) ~~> cc]]   \\
                                     & \qquad \Longrightarrow \kleq{[[cc{e1}]]}{[[cc{e2}]]})
  \end{align*}
\end{definition}


The connection between disjointness and the value relation becomes a bit
complicated due to the addition of type variables. We first prove that disjoint
values of monotypes are related.


\begin{lemma}[Disjoint values of monotypes are related] \label{lemma:disjoint:mono}
  If $[[empty |- t1 ** t2]]$,
  $[[  empty ; empty |-  v1 : |t1|  ]]$ and
  $[[  empty ; empty |-  v2 : |t2|  ]]$
  then $[[   (v1, v2) in V ( t1 ; t2  )    ]]$.
\end{lemma}
\begin{proof}
  By simultaneous induction on $[[t1]]$ and $[[t2]]$.
\end{proof}

Then we can prove a more general lemma.

\begin{lemma}[Disjoint values are related]
  If $[[DD |- A ** B]]$, $[[ p in DD  ]]$, $[[  empty ; empty |-  v1 : |p (A)|  ]]$ and $[[  empty ; empty |-  v2 : |p (B)|  ]]$
  then $[[   (v1, v2) in V ( p(A) ; p(B)  )    ]]$.
\end{lemma}
\begin{proof}
  By induction on the derivation of disjointness. The most interesting case is the variable rule:
  \[
    \drule{FD-tvarL}
  \]
  By the definition of $[[p]]$, we know $[[p(X)]]$ is a monotype. If $[[B]]$ is
  a polytype, then it follows easily from the definition of logical relation. If
  $[[B]]$ is also a monotype, we know $[[p(X)]]$ and $[[p(A)]]$ are disjoint by
  definition. Then by \cref{lemma:covariance:disjoint} and $[[A <: B]]$,
  we have $[[p(X)]]$ and $[[p(B)]]$ are also disjoint. Finally we apply
  \cref{lemma:disjoint:mono}.
\end{proof}


Next up are the compatibility lemmas. They are essentially the same as in
\cref{chap:coherence:simple}. So we skip them and state the last two important
theorems without giving proofs. The proofs have mostly the same structures as in the
simply-typed case, but with more cases. The interested reader can refer to our
Coq formalization.

\begin{theorem}[Fundamental Property] We have that:
  \begin{itemize}
  \item If $[[DD; GG |- ee => A ~~> e]]$ and $[[DD; GG |- ee => A ~~> e']]$, then $[[DD; GG |- e == e' : A ]]$.
  \item If $[[DD ; GG |- ee <= A ~~> e]]$ and $[[DD ; GG |- ee <= A ~~> e']]$, then $[[DD; GG |- e == e' : A ]]$.
  \end{itemize}
\end{theorem}

\begin{theorem}[Congruence]
 If $[[CC : (DD ; GG dir A) ~> (DD' ; GG' dir' A') ~~> cc]]$, $[[DD ; GG |- ee1 dir A ~~> e1]]$, $[[DD ; GG |- ee2 dir A ~~> e2]]$
 and $[[DD ; GG |- e1 == e2 : A ]]$, then $[[DD' ; GG' |- cc{e1} == cc{e2} : A']]$.
\end{theorem}

Finally \fnamee is coherent.

\begin{theorem}[Coherence of \fnamee] We have that
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ]]$ then $[[DD ; GG |- ee ~= ee : A]]$.
  \item If $[[DD ; GG |- ee <= A ]]$ then $[[DD ; GG |- ee ~= ee : A]]$.
  \end{itemize}
\end{theorem}


\paragraph{Final remarks.}

It would be interesting to study parametricity of \fnamee. As we have seen, it
is not obvious how to extend the parametric logical relation as defined in
\cref{fig:logical:f} to account for disjointness, and avoid potential
circularity due to impredicativity. A possible solution is to use step-indexed
logical relations. We have yet investigated further on that direction.

% Local Variables:
% TeX-master: "../../Thesis"
% org-ref-default-bibliography: ../../Thesis.bib
% End: