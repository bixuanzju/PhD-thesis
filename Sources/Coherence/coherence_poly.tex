
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Coherence for \fnamee}
\label{chap:coherence:poly}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we extend the proof technique introduced in
\cref{chap:coherence:simple} to prove coherence for \fnamee. Firstly we review
the parametric logical relation for System F~\citep{reynolds1983types} in
\cref{sec:para:lr}. We then talk about a failed attempt on naturally extending
it to disjoint intersection types in \cref{sec:failed:lr}. The technical
difficulty stems from the interaction between impredicativity and disjointness.
Finally in \cref{sec:succeed:lr}, we present our (predicative) logical relation
that is specially crafted to prove coherence for \fnamee, and talk about
potential solutions to lift the predicativity restriction.


\section{Review of the Parametric Logical Relation}
\label{sec:para:lr}

\begin{figure}[t]
  \centering
  \begin{tabular}{lll}
  $[[(v1 , v2) in V ( X ) with pq ]]$  &$\defeq$ & $ ([[v1]], [[v2]]) \in [[pq]]([[X]])   $ \\
  $[[(v1 , v2) in V ( nat ) with pq ]]$  &$\defeq$ & $\exists [[i]].\, [[v1]] = [[v2]] = [[ii]]$ \\
  $[[(v1 , v2) in V ( T1 -> T2 ) with pq ]]$  & $\defeq$ & $\forall [[(v'1, v'2) in V (T1) with pq  ]].\, [[  (v1 v1' , v2 v2') in E (T2) with pq   ]]$ \\
  $[[(v1 , v2) in V ( T1 * T2 ) with pq ]]$  & $\defeq$ & $[[( pp1 v1, pp1 v2 ) in E (T1) with pq ]]  \land [[ (pp2 v1, pp2 v2) in E (T2) with pq ]]   $ \\
  $[[(v1 , v2) in V ( \X . T ) with pq ]]$  & $\defeq$ & $ \forall [[T1]], [[T2]], [[R]] \subseteq [[T1]] \times [[T2]].\, [[ (v1 T1, v2 T2) in E (T) with pq [X -> R ]     ]]  $ \\ \\
  $[[(e1, e2) in E (T) with pq ]]$ & $\defeq$ & $\exists [[v1]], [[v2]].\, [[e1 -->> v1]] \land [[e2 -->> v2]] \land [[(v1, v2) in V (T) with pq ]]$
  \end{tabular}
  \caption{A logical relation for System F}
  \label{fig:logical:f}
\end{figure}

System F provides a reasoning principle called \textit{relational
  parametricity}~\citep{reynolds1983types} for establishing when two expressions
of the same type have identical behavior. The principle is expressed in terms of
a logical relation. It is well-known that the logical relation of System F
induces the \textit{abstraction theorem} (also called the \textit{parametricity
  theorem}) of \citet{reynolds1983types}, which roughly says that every
well-typed expression behaves the same as itself according to its type. The
stringency of parametricity ensures that a polymorphic type has very few
inhabitants, so few that we can deduce the behavior of a program by just looking
at its type, which \citet{wadler1989theorems} christened \textit{theorems for
  free}.

Consider an expression $[[e]]$ of type $[[ \X . X -> nat ]]$. The following
``free'' theorem completely determines the behavior of $[[e]]$ and any other
function of the same type -- i.e., all expressions with this type have to be constant
functions.

\begin{theorem}[A free theorem of $[[ \X . X -> nat ]]$] \label{thm:free}
  Suppose $[[e]]$ is any expression of type $[[\X . X -> nat]]$. Let $[[T1]]$
  and $[[T2]]$ be arbitrary types. For any $[[v1]]$ of type $[[T1]]$ and
  $[[v2]]$ of type $[[T2]]$,
  \[
    [[e T1 v1 -->> v3]] \land [[e T2 v2 -->> v4]] \land [[v3]] = [[v4]]
  \]
\end{theorem}


\Cref{fig:logical:f} defines the logical relation for call-by-value System F.
Compared with the logical relation for simple types, it is parameterized by a
relational mapping $[[pq]]$, which plays a central role for type abstractions
and type variables. Intuitively, for two values $[[v1]]$ and $[[v2]]$ of type
$[[\X . T]]$ to behave the same, their instantiations must behave the same.
However, because $[[v1]]$ and $[[v2]]$ do not manipulate the values of type
$[[X]]$, it is not required that they should behave the same at the
\textit{same} instantiation. Indeed, as we see in \cref{thm:free}, we shall be
able to consider \textit{separately} instances of $[[v1]]$ and $[[v2]]$ by types
$[[T1]]$ and $[[T2]]$, and treat the type variable $[[X]]$ as standing for any
relation $[[R]]$ between $[[T1]]$ and $[[T2]]$. Now it is apparent that the
relational mapping $[[pq]]$ maps each type variable $[[X]]$ to a relation
$[[R]]$ that says how values at type $[[X]]$ should be related. This explains
why for type variables, values of type $[[X]]$ are related according to the
relation associated with $[[X]]$ in the mapping $[[pq]]$.



\section{Impredicativity and Disjointness at Odds}
\label{sec:failed:lr}

Based on the parametric logical relation of System F, it is not hard to come up
with a heterogeneous version, similar to \cref{fig:logical}, but with a
relational mapping. Below is the definition for functions and intersection types.
\begin{align*}
 [[(v1, v2)  in V(A1 -> B1; A2 -> B2) with pq ]] &\defeq \forall [[(v'1, v'2) in V (A1; A2) with pq  ]].\, [[  (v1 v1' , v2 v2') in E (B1 ; B2) with pq   ]] \\
  [[( < v1 , v2 > , v3  )  in V ( A & B ;  C  ) with pq ]]  &\defeq [[ (v1, v3)  in V (A ; C) with pq ]] \land [[ (v2, v3)  in V (B ; C) with pq ]] \\
  [[( v3 , < v1 , v2 >  )  in V ( C ; A & B  ) with pq ]]  &\defeq [[ (v3, v1)  in V (C ; A) with pq ]] \land [[ (v3, v2)  in V (C ; B) with pq ]]
\end{align*}
They do not manipulate $[[pq]]$ and are thus directly ported from
\cref{fig:logical}. For type abstractions, we follow the definition for System
F, but also take care of disjointness constraint, as shown below.
\begin{align*}
  [[(v1, v2)  in V(\X ** A1 . B1; \X ** A2 . B2) with pq ]] &\defeq \forall [[empty |- C1 ** pq(A1 & A2) ]], [[empty |- C2 ** pq(A1 & A2)]], \\
                                                            & \quad [[R]] \subseteq [[C1]] \times [[C2]]. \\
                                                            & \quad [[ ( v1 |C1|, v2 |C2|) in V (B1 ; B2) with pq[X -> R]    ]]
\end{align*}
That is, it quantifies over all types that meet the disjointness constraint. For
type variables, things become a bit complicated. If we have the same type
variable, it falls back to the familiar definition for System F.
\begin{align*}
  [[(v1, v2)  in V(X; X) with pq ]] &\defeq ([[v1]], [[v2]]) \in [[pq]]([[X]])
\end{align*}
But what about when they are different variables, or one is a different type? A
seemingly innocuous definition is as follows.
\begin{align*}
  [[(v1, v2)  in V(X; A) with pq ]] &\defeq [[ (v1, v2) in V(pq(X); pq(A)) with emp  ]]
\end{align*}
That is, given $[[v1]]$ of type $[[X]]$ and $[[v2]]$ of type $[[A]]$ ($[[A]]
\neq [[X]]$), they are related at $[[X]]$ and $[[A]]$ if and only if they are
related at $[[pq(X)]]$ and $[[pq(A)]]$~\footnote{Here we are abusing the
  notation with the intention that $[[pq(X)]]$ means the assigned type of
  $[[X]]$ in $[[pq]]$; and $[[pq(A)]]$ means substituting all the variables
  mentioned in $[[pq]]$ with the corresponding types in $[[A]]$.}. To see why we
need to get the assigned type of $[[X]]$ in $[[pq]]$, suppose we have an
expression $[[\ X ** nat . \x . x]]$ of type $[[ \ X ** bool . X & nat -> X & nat ]]$,
we should expect the following to hold:\footnote{The reader is advised to try it out in our prototype interpreter.}
\[
  [[(\ X ** bool . \x . x) nat 1 -->> <1 , 1> ]]
\]
According to the definition in question, it boils down to verify the following:
\[
  [[  (1 , 1) in V (X ; nat) with pq  ]]
\]
where the mapping $[[pq]]$ maps $[[X]]$ to a relation over integers. And if we
replace $[[X]]$ with $[[nat]]$ then the above holds trivially.


However, the seemingly innocuous definition for type variables has a serious
issue with impredicativity -- i.e, the relation in question is \textit{not
  well-founded}. We could pick a bad instantiation to make the relation ``go
into a loop''. For example, suppose $[[pq]]$ only contains a mapping from $[[X]]$ to
$[[\X . \Y . Y]]$, we then have the following infinite chain of equational reasoning:
\[
 \valR{[[X]]}{[[\Y . Y]]}_{[[pq]]} = \valR{[[\X . \Y . Y]]}{[[\Y. Y]]}_{[[emp]]} = \eeR{[[\Y . Y]]}{[[ X ]]}_{[[pq]]} = \valR{[[\Y . Y]]}{[[ X ]]}_{[[pq]]} = \dots
\]
The culprit is the polymorphic instantiation $[[\X . \Y . Y]]$, which is larger
than $[[\Y . Y]]$. This is the exact circumstance where in \cref{fig:logical:f}
substitution is deliberately avoided in the definition for type abstractions.

\section{Predicative Logical Relation}
\label{sec:succeed:lr}

In light of the fact that substitution in the logical relation seems unavoidable
in our setting, and that impredicativity conflicts with substitution, we turn
to, for the lack of a better logical relation, predicativity. On the other hand,
a predicative system seems to be a reasonable choice in that later we want to
study implicit polymorphism based on \fnamee, which is briefly discussed in
\cref{sec:implicit}.

\begin{figure}
  \centering
  \begin{small}
  \begin{tabular}{lll}
  $[[(v1 , v2) in V ( nat ; nat ) ]]$  & $\defeq$ & $\exists [[i]].\, [[v1]] = [[v2]] = [[ii]]$ \\
  $[[(v1, v2) in V ( {l : A}  ; {l : B} ) ]]$ & $\defeq$ & $[[ (v1, v2) in V ( A ; B ) ]]$\\
  $[[(v1 , v2) in V ( A1 -> B1 ; A2 -> B2 ) ]]$  & $\defeq$ & $\forall [[(v2' , v1') in V ( A2 ; A1 ) ]].\, [[ (v1 v1' , v2 v2') in E ( B1 ; B2 ) ]]$ \\
    $\hlmath{[[(v1, v2)  in V ( \ X ** A1 . B1; \ X ** A2 . B2 ) ]]}$  &$\defeq$ & $\hlmath{\forall [[empty |- t ** A1 & A2 ]].}$ \\
                                       && $\hlmath{[[  (v1 |t| , v2 |t|) in E ( [t / X] B1 ; [t / X] B2) ]]}$ \\
  $[[( < v1 , v2 > , v3  )  in V ( A & B ;  C  ) ]]$  & $\defeq$ & $[[ (v1, v3)  in V (A ; C) ]] \land [[ (v2, v3)  in V (B ; C) ]]$  \\
  $[[( v3 , < v1 , v2 >  )  in V ( C; A & B  ) ]]$  & $\defeq$ & $[[ (v3, v1)  in V (C ; A) ]] \land [[ (v3, v2)  in V (C ; B) ]]$  \\
  $[[(v1 , v2) in V (A; B) ]]$  & $\defeq$ & $\mathsf{true} \quad \text{otherwise}$ \\ \\
    $[[(e1, e2) in E (A; B)]]$ & $\defeq$ & $\exists [[v1]], [[v2]].\, [[e1 -->> v1]] \land [[e2 -->> v2]] \ \land $ \\
                                       & & $[[(v1, v2) in V (A; B)]]$
  \end{tabular}
  \end{small}
  \caption{Logical relation for \fnamee}
  \label{fig:logical:fi}
\end{figure}

Substitution with predicative instantiations does not prevent well-foundedness.
\Cref{fig:logical:fi} presents the logical relation for \fnamee. We extend the
logical relation in \cref{fig:logical} with a new clause (highlighted) for
disjoint quantification. Notice that it quantifies over a \textit{single}
monotype $[[t]]$, unlike the tradition formulation (see \cref{fig:logical:f}).
This suffices for our purposes to prove coherence. Also notice that we directly
substitute $[[X]]$ with $[[t]]$ in both $[[B1]]$ and $[[B2]]$. It can shown that
the resulting term $[[ [t / X] B1 ]]$ is smaller than $[[ \X ** A1 . B1 ]]$.

\begin{lemma}[Well-foundedness]
  The logical relation as defined in \cref{fig:logical:fi} is well-founded.
\end{lemma}
\begin{proof}
  Let $| \cdot |_{\forall}$ and $| \cdot |_s$ denote the number of
  $\forall$-quantifies and the size of types, respectively. The following
  measure suffices to prove well-foundedness:
  \[
\langle | \cdot |_{\forall} ,  | \cdot |_s   \rangle
  \]
  where $\langle \dots \rangle$ denotes lexicographic order. We can verify that
  for the clause of disjoint quantification, the number of $\forall$-quantifies
  decreases, because the monotype $[[t]]$ does not contain $\forall$-quantifies.
  For the other clauses, either the measure of $| \cdot |_{\forall}$ decreases,
  or it remains the same but the measure of $| \cdot |_s$ decreases.
\end{proof}








% Local Variables:
% TeX-master: "../../Thesis"
% org-ref-default-bibliography: ../../Thesis.bib
% End:
