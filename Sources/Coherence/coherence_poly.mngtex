
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Coherence for \fnamee}
\label{chap:coherence:poly}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we establish the coherence property for \fnamee. The proof
strategy mostly follows that of \namee, but the construction of the
heterogeneous logical relation is significantly more complicated. Firstly in
\cref{sec:para:intuition} we discuss why adding BCD subtyping to disjoint
polymorphism introduces significant complications. In
\cref{sec:failed:lr}, we discuss why a natural extension of
System F's logical relation to deal with disjoint polymorphism fails. The technical
difficulty is \emph{well-foundedness}, stemming from the interaction between
impredicativity and disjointness. Finally in \cref{sec:succeed:lr}, we present
our (predicative) logical relation that is specially crafted to prove coherence
for \fnamee.
% and allude to a potential solution to lift the predicativity restriction.

\section{The Challenge}
\label{sec:para:intuition}

Before we tackle the coherence of \fnamee, let us first consider how \fname
(and its predecessor \oname) enforces coherence. Its essentially syntactic
approach is to make sure that there is at most one subtyping derivation for any
two types. As an immediate consequence, the produced coercions are uniquely determined and thus
the calculus is clearly coherent. Key to this approach is the invariant that
the type system only produces \emph{disjoint} intersection types. As we
mentioned in \cref{sec:fi:typesystem}, this invariant complicates the calculus
and its metatheory, and leads to a weaker substitution lemma.
% To see this, consider the judgment $[[ X ** int |- X & int ]]$.
% Clearly $[[X]]$ cannot be instantiated to an arbitrary type. For
% instance, substituting $[[X]]$ with $[[int]]$ would lead to an ill-formed
% intersection type $[[int & int]]$ in \fname.
% Therefore in the
% substitution lemma, the range of substituted types is narrowed down to those
% that respect the disjointness constraints.
% The motivation of maintaining this invariant was to enable
% Generally speaking, in \fname all meta-theoretic properties are weakened to
% account for disjointness pre-conditions. All of these contribute
Moreover, the syntactic coherence approach is incompatible with BCD subtyping,
which leads to multiple subtyping derivations with different coercions and
requires a more general substitution lemma. For example, consider the
coercions produced by $[[ \X ** int . X & X <: \X ** int & int . X ]]$ (neither
type is ``well-formed'' in the sense of \fname). Two possible ones are
$[[ \f . \X . pp1 (f X) ]]$ and $[[ \f . \X . pp2 (f X) ]]$. It is not at all
obvious that they should be equivalent in an appropriate sense.
As we have shown in \cref{chap:coherence:simple}, to prove coherence for \namee,
we need a semantically-founded proof method based on logical relations.
Because \namee does not feature polymorphism, the problem at hand is to
incorporate support for polymorphism in this semantic approach to coherence,
which turns out to be more challenging than is apparent.

% preclude the possibility of adding BCD
% subtyping, which requires a general substitution lemma. This implies that the
% avenue taken by Alpuim et al.~\cite{alpuimdisjoint} to prove coherence does not
% work for \fnamee anymore. In particular, subtyping does not necessarily produces unique
% coercions. For example, consider the possible coercions generated by $[[ \X ** int . X & X <: \X ** int & int . X ]]$ (neither of which is ``well-formed''
% in the sense of \fname). Two possible coercions are $[[ \f . \X . pp1 (f X) ]]$
% and $[[ \f . \X . pp2 (f X) ]]$. It is not at all obvious that these two
% coercions are equivalent in an appropriate sense. Moreover, the addition of BCD subtyping
% aggravates the matter even more---the subtyping relation can produce additional
% syntactically different coercions that are harder to argue to be equivalent.
% Inspired by Bi et al.~\cite{bi_et_al:LIPIcs:2018:9227}, a new semantically-founded
% proof method is called for. Logical relations \`a la System F might shed some
% light, as we will discuss next.

\section{Impredicativity and Disjointness at Odds}
\label{sec:failed:lr}

% \Cref{fig:logical:necolus} shows selected cases of \emph{canonicity},
% which is \namee's (heterogeneous) logical relation used
% in the coherence proof. The definition captures that two values
% $[[v1]]$ and $[[v2]]$ of types $[[ T1 ]]$ and $[[T2]]$ are in $\valR{[[T1]]}{[[T2]]}$ iff
% either the types are disjoint or the types are equal and the values are
% semantically equivalent. Because both alternatives entail coherence,
% canonicity is key to \namee's coherence proof.

\paragraph{Well-foundedness issues.}
For \fnamee, we need to extend canonicity with additional cases to
account for universally quantified types.
A naive formulation of one case rule is:
\begin{align*}
    &[[(v1, v2)  in V(\X ** A1 . B1; \X ** A2 . B2) ]] \defeq  \\
    &\qquad \forall [[C1 ** A1]], [[C2 ** A2]].\ [[( v1 | C1 | , v2 | C2 | ) in E ( [C1 / X] B1 ; [C2 / X] B2 ) ]]
\end{align*}
This case is problematic because it destroys the well-foundedness of \namee's
logical relation, which is based on structural induction on the type indices.
Indeed, the type $[[ [C1 / X] B1  ]]$ may well be larger than $[[ \X ** A1 . B1 ]]$.


% \begin{verbatim}
% Further outline
% - show System F-style case with deferred substitions
% - introduce variable case
% - show well-foundedness problem with variable case (also present in System F)
% - show System F solution for the problem by adding a relation parameter R
% - introduce problem with heterogeneous case
% \end{verbatim}

However, System F's well-known parametricity logical
relation~\citep{reynolds1983types} provides us with a means to avoid this
problem.  Rather than performing the type substitution immediately as in the
above rule, we can defer it to a later point by adding it to an extra parameter
$[[pq]]$ of the relation, which accumulates the deferred substitutions. This yields a modified rule where the type indices in the recursive occurrences are indeed smaller:
\begin{align*}
  &[[(v1, v2)  in V(\X ** A1 . B1; \X ** A2 . B2) with pq ]]  \defeq  \\
  &\qquad \forall [[C1 ** A1]], [[C2 ** A2]]. ([[v1 | C1 | ]] ,  [[v2 | C2 |]]) \in \eeR{[[B1]]}{{[[B2]]}}_{[[pq]] [ [[X]] \mapsto ([[C1]], [[C2]])]}
\end{align*}
Of course, the deferred substitution has to be performed eventually, to be precise when the type indices are type variables.
\[
    [[(v1, v2)  in V(X ; X) with pq ]] \defeq [[ (v1, v2) in V(pq1 (X); pq2 (X)) with emp  ]]
\]
Unfortunately, this way we have not only moved the type substitution to the type variable case, but also the ill-foundedness problem. Indeed, this problem is also
present in System F. The standard solution is to not fix the relation $[[Rel]]$ by which values
at type $[[X]]$ are related to $\valR{[[pq1 (X)]]}{[[pq2 (X)]]}$, but instead to make it a parameter that is tracked by $[[pq]]$.
This yields the following two rules for disjoint quantification and type variables:
\begin{align*}
  [[(v1, v2)  in V(\X ** A1 . B1; \X ** A2 . B2) with pq ]] &\defeq \forall [[C1 ** A1]], [[C2 ** A2]], [[Rel]] \subseteq [[C1]] \times [[C2]]. \\
                                                            & ([[v1 | C1 | ]] ,  [[v2 | C2 |]]) \in \eeR{[[B1]]}{{[[B2]]}}_{[[pq]] [ [[X]] \mapsto ([[C1]], [[C2]], [[Rel]])]} \\
    [[(v1, v2)  in V(X; X) with pq ]] & \defeq ([[v1]], [[v2]]) \in [[pq]]_{[[Rel]]}([[X]])
\end{align*}
Now we have finally recovered the well-foundedness of the relation. It is again
structurally inductive on the size of the type indexes.


\paragraph{Heterogeneous issues.}

We have not yet accounted for one major difference between the parametricity relation, from which we have borrowed ideas, and the canonicity relation, to which we have been adding. The former is homogeneous (i.e., the types of the two values is the same) and therefore has one type index, while the latter is heterogeneous (i.e., the two values may have different types) and therefore has two type indices. Thus we must also consider cases like
$\valR{[[X]]}{[[int]]}$. A definition that seems to handle this case
appropriately is:
  \begin{align} \label{eq:var}
    [[(v1, v2)  in V(X; int) with pq ]] \defeq [[ (v1, v2) in V(pq1 (X); int) with emp  ]]
  \end{align}
Here is an example to motivate this case.
Let  $  [[ee]] = [[\ X ** Top . (\x . x) : X & int -> X & int]] $.
We expect that $[[ee int 1 -->> <1 , 1> ]]$, which
%%\footnote{The reader is advised to try it out in our prototype interpreter.}
boils down to showing $  (1 , 1)   \in \valR{[[X]]}{[[int]]}_{[ [[X]] \mapsto ([[int]], [[int]], [[Rel]])   ]}  $.
According to \cref{eq:var}, this is indeed the case. However, we run into ill-foundedness issue again, because
$[[pq1 (X)]]$ could be larger than $[[X]]$. Alas, this time the parametricity relation has no solution for us.


\section{The Canonicity Relation for \fnamee}
\label{sec:succeed:lr}

% \bruno{Perhaps we are still showing too many auxiliary lemmas here? We
% could cut on some of these if we are looking for space.}
In light of the fact that substitution in the logical relation seems unavoidable
in our setting, and that impredicativity is at odds with substitution, we turn
to \emph{predicativity}: we change \rref{FT-tapp} to its predicative version:
\[
  \drule{FT-tappMono}
\]
where metavariable $[[t]]$ ranges over monotypes, whose syntax is shown below
\[
    \text{Monotypes} \quad [[t]] \Coloneqq [[int]] \mid [[Top]] \mid [[t1 -> t2]]  \mid [[t1 & t2]] \mid [[{l : t}]] \mid [[X]]
\]
We do not believe that predicativity is a severe restriction in practice, since many source
languages (e.g., those based on the Hindley-Milner type system~\citep{milner1978theory, hindley1969principal} like Haskell and
OCaml) are themselves predicative and do not require the full generality of an
impredicative core language.

% The restriction to
% predicative polymorphism, though reducing expressiveness in theory, does not seem to cost much
% in practice. Languages based on the Hindleyâ€“Milner type
% system~\cite{milner1978theory, hindley1969principal}, such as Haskell and ML,
% have such restriction. We also plan to study a variant of \fnamee with implicit
% polymorphism in the future, where a predicativity restriction is
% likely to be required anyway.

\begin{figure}[t]
  \centering
  \begin{small}
  \begin{tabular}{rll}
    $[[(v1 , v2) in V ( int ; int ) ]]$  & $\defeq$ & $\exists [[i]].\, [[v1]] = [[v2]] = [[i]]$ \\
    $[[(v1, v2) in V ( {l : A}  ; {l : B} ) ]]$ & $\defeq$ & $[[ (v1, v2) in V ( A ; B ) ]]$\\
    $[[(v1 , v2) in V ( A1 -> B1 ; A2 -> B2 ) ]]$  & $\defeq$ & $\forall [[(v2' , v1') in V ( A2 ; A1 ) ]].\, [[ (v1 v1' , v2 v2') in E ( B1 ; B2 ) ]]$ \\
    $[[( < v1 , v2 > , v3  )  in V ( A & B ;  C  ) ]]$  & $\defeq$ & $[[ (v1, v3)  in V (A ; C) ]] \land [[ (v2, v3)  in V (B ; C) ]]$  \\
    $[[( v3 , < v1 , v2 >  )  in V ( C; A & B  ) ]]$  & $\defeq$ & $[[ (v3, v1)  in V (C ; A) ]] \land [[ (v3, v2)  in V (C ; B) ]]$  \\
    $[[(v1, v2)  in V ( \ X ** A1 . B1; \ X ** A2 . B2 ) ]]$  &$\defeq$ & $\forall [[empty |- t ** A1 & A2 ]].\ [[  (v1 |t| , v2 |t|) in E ( [t / X] B1  ;  [ t / X] B2 ) ]]$ \\
    $[[(v1 , v2) in V (A; B)]] $  &$\defeq$ & $\mathsf{true} \quad \text{otherwise} $ \\ \\
    $[[(e1, e2) in E (A; B)]]$ & $\defeq$ & $\exists [[v1]], [[v2]].\, [[e1 -->> v1]] \land [[e2 -->> v2]] \ \land [[(v1, v2) in V (A; B)]]$
  \end{tabular}
  \end{small}
  \caption{The canonicity relation for \fnamee}
  \label{fig:logical:fi}
\end{figure}

Luckily because monotypes do not contain $\forall$-quantifiers, substitution
with monotypes does not prevent well-foundedness. \Cref{fig:logical:fi} defines
the \emph{canonicity} relation for \fnamee. The canonicity relation is a family
of binary relations over \tnamee values that are \emph{heterogeneous}, i.e.,
indexed by two \fnamee types.
% Two points are worth mentioning.
% (1) An apparent difference from \namee's logical
% relation is that our relation is now indexed by \emph{source types}. The reason is that
% the type translation function (\cref{def:type:translate:fi}) discards disjointness
% constraints, which are crucial in our setting, whereas \namee's
% type translation does not have information loss. (2) Heterogeneity
% allows relating values of different types, and in particular values whose types are
% disjoint.
% The rationale behind the canonicity relation is to combine equality
% checking from traditional (homogeneous) logical relations with disjointness
% checking.
It consists of two relations: the value relation $\valR{[[A]]}{[[B]]}$
relates \emph{closed} values; and the expression relation
$\eeR{[[A]]}{[[B]]}$---defined in terms of the value relation---relates closed
expressions.

% \paragraph{Value relation.}

The relation $\valR{[[A]]}{[[B]]}$ is defined by induction on the structures of $[[A]]$ and
$[[B]]$. For integers, it requires the two values to be literally the same. For
two records to behave the same, their fields must behave the same. For two
functions to behave the same, they are required to produce outputs related at
$[[B1]]$ and $[[B2]]$ when given related inputs at $[[A1]]$ and $[[A2]]$. For
the next two cases regarding intersection types, the relation distributes
over intersection constructor $[[&]]$. Of particular interest is the case for
disjoint quantification. Notice that it \emph{does not} quantify over arbitrary
relations, but directly substitutes $[[X]]$ with monotype $[[t]]$ in $[[B1]]$ and
$[[B2]]$. This means that our canonicity relation \emph{does not} entail
parametricity~\citep{reynolds1983types}. % , and as such, the free theorem in \cref{sec:failed:lr}
% cannot be proved using the canonicity relation.
However, it suffices for our purposes to prove coherence. Another noticeable
thing is that the value relation $\valR{[[A]]}{[[B]]}$ (and
$\eeR{[[A]]}{[[B]]}$) keeps the invariant that $[[A]]$ and $[[B]]$ are closed
types. As a result, type variables need not to be
considered in the logical relation. This simplifies things a lot. % The
% other cases are quite standard.
Note that when one type is $[[Bot]]$, two
values are vacuously related because there simply are no values of type $[[Bot]]$.
% We refer to Bi et al.~\cite{bi_et_al:LIPIcs:2018:9227} for more explanations of
% the canonicity relation.
We need to show that the relation is indeed well-founded:

\begin{restatable}[Well-foundedness]{lemma}{wellfounded}\label{lemma:well-founded}
  The canonicity relation of \fnamee is well-founded.
\end{restatable}
\begin{proof}
  Let $| \cdot |_{\forall}$ and $| \cdot |_s$ be the number of
  $\forall$-quantifies and the size of types, respectively. We consider the measure $\langle
  | \cdot |_{\forall} , | \cdot |_s \rangle$,
  where $\langle \dots \rangle$ denotes lexicographic order. For the case of
  disjoint quantification, the number of $\forall$-quantifiers decreases because monotype $[[t]]$ does not contain $\forall$-quantifiers.
  For the other cases, the measure of $| \cdot |_{\forall}$ does not increase, and
  the measure of $| \cdot |_s$ strictly decreases.
\end{proof}

Next we show that the logical relation is symmetric.

\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L822}{\leftpointright} Symmetry of logical relation] % APPLYCOQ=LOG_SYMM
  If $[[ (v1, v2) in V ( A ; B ) ]]$ then $[[ (v2, v1) in V ( B ; A ) ]]$.
\end{lemma}
\begin{proof}
  Symmetry of \cref{fig:logical} is trivial. For \cref{fig:logical:fi}, the
  proof proceeds by first induction on $ | [[A]] |_{\forall} $, then simultaneous
  induction on the structures of $[[A]]$ and $[[B]]$.
\end{proof}

We then give the interpretations of type and term contexts.

\begin{definition}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/Infrastructure.v\#L2023}{\leftpointright} Interpretation of type contexts]
  \begin{mathpar}
    \ottaltinferrule{}{}{  }{ [[emp in empty]] } \and
    \ottaltinferrule{}{}{ [[p in DD]] \\ [[empty |- t ** p(B)]] \\  }{ [[p [ X -> t ] in DD , X ** B]]  }
  \end{mathpar}
\end{definition}


\begin{definition}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L166}{\leftpointright} Interpretation of value contexts]
  \begin{mathpar}
    \ottaltinferrule{}{}{  }{ [[(emp, emp) in empty with p ]]  } \and
    \ottaltinferrule{}{}{ [[(g1, g2) in GG with p ]] \\ [[(v1, v2) in V (p(A)) ]] }{ [[(g1 [ x -> v1 ] , g2 [ x -> v2 ]  )  in GG , x : A with p ]] }
  \end{mathpar}
\end{definition}


The connection between disjointness and the value relation becomes a bit
complicated due to the addition of polymorphism. We first prove that
values of disjoint monotypes are related.


\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L836}{\leftpointright} Disjoint values of monotypes are related] \label{lemma:disjoint:mono} % APPLYCOQ=DISJOINT_MONO
  If $[[empty |- t1 ** t2]]$,
  $[[  empty ; empty |-  v1 : |t1|  ]]$ and
  $[[  empty ; empty |-  v2 : |t2|  ]]$
  then $[[   (v1, v2) in V ( t1 ; t2  )    ]]$.
\end{lemma}
\begin{proof}
  By simultaneous induction on $[[t1]]$ and $[[t2]]$.
\end{proof}

Then we can prove a more general lemma.

\begin{lemma}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/LR.v\#L1114}{\leftpointright} Disjoint values are related] % APPLYCOQ=DISJOINT_VALUE
  If $[[DD |- A ** B]]$, $[[ p in DD  ]]$, $[[  empty ; empty |-  v1 : |p (A)|  ]]$ and $[[  empty ; empty |-  v2 : |p (B)|  ]]$
  then $[[   (v1, v2) in V ( p(A) ; p(B)  )    ]]$.
\end{lemma}
\begin{proof}
  By induction on the derivation of disjointness. The most interesting case is the variable rule:
  \[
    \drule{FD-tvarL}
  \]
  By the definition of $[[p]]$, we know $[[p(X)]]$ is a monotype. If $[[B]]$ is
  a polytype, then it follows easily from the definition of logical relation. If
  $[[B]]$ is also a monotype, we know $[[p(X)]]$ and $[[p(A)]]$ are disjoint by
  definition. Then by \cref{lemma:covariance:disjoint} and $[[A <: B]]$,
  we have $[[p(X)]]$ and $[[p(B)]]$ are also disjoint. Finally we apply
  \cref{lemma:disjoint:mono}.
\end{proof}






\section{Establishing Coherence}

We are now ready to prove coherence for \fnamee. The proof of coherence
basically follows that in \cref{chap:coherence:simple}.

\paragraph{Logical equivalence.}

The canonicity relation can be lifted to open expressions in the standard way,
i.e., by considering all possible interpretations of free type and term variables.

\begin{definition}[Logical equivalence $\backsimeq_{log}$]
  \begin{align*}
    &[[DD ; GG |- e1 == e2 : A ; B]]   \defeq  [[|DD| ; |GG| |- e1 : |A|]] \land [[ |DD | ; |GG| |- e2 : | B | ]] \ \land \\
    &\qquad (\forall [[p]], [[g1]], [[g2]]. \ [[p in DD]] \land [[(g1, g2) in GG with p ]] \Longrightarrow [[(g1 (p1 (e1)), g2 (p2 (e2)))  in E (p(A) ; p(B)) ]])
  \end{align*}
\end{definition}
For conciseness, we write $[[DD ; GG |- e1 == e2 : A]]$ to mean $[[DD ; GG |- e1 == e2 : A ; A]]$.

\paragraph{Contextual equivalence.}

\begin{figure}[t]
  \centering
\begin{tabular}{llll}\toprule
  \tnamee contexts & $[[cc]]$ & $\Coloneqq$ &  $[[__]] \mid [[\ x . cc]] \mid [[\ X . cc]]  \mid [[ cc T  ]] \mid [[cc e]] \mid [[e cc]] \mid [[< cc , e>]] \mid [[<e , cc>]] \mid [[c cc]] $ \\
  \fnamee contexts & $[[CC]]$ & $\Coloneqq$ &  $[[__]] \mid [[\ x . CC]] \mid [[\ X ** A. CC]] \mid [[ CC A  ]] \mid [[CC ee]] \mid [[ee CC]] \mid [[ CC ,, ee  ]] \mid [[ ee ,, CC  ]]  $ \\
  & & $\mid$ & $ [[ { l = CC}  ]]  \mid [[ CC . l]] \mid [[ CC : A ]]$ \\ \bottomrule
\end{tabular}
  \caption{Expression contexts}
  \label{fig:contexts:fi}
\end{figure}

Following \namee, the notion of coherence is based on \emph{contextual
  equivalence}. The intuition is that two programs are equivalent if we
\emph{cannot} tell them apart in any context. More formally, we introduce
\emph{expression contexts}, whose syntax is shown in \cref{fig:contexts:fi}. Due
to the bidirectional nature of the type system, the typing judgment of $[[C]]$
features 4 different forms (see \cref{appendix:fi}),
e.g., $[[CC : (DD; GG => A) ~> (DD'; GG' => A') ~~> cc]]$ reads if $[[DD ; GG |- ee => A]]$
then $[[DD' ; GG' |- CC { ee } => A']]$. The judgment also generates a well-typed \tnamee context $[[cc]]$. The
following definition capture the notion of contextual equivalence in \fnamee:

% \begin{definition}[Kleene Equality $\backsimeq$]
%   Two complete programs, $[[e]]$ and $[[e']]$, are Kleene equal, written
%   $\kleq{[[e]]}{[[e']]}$, iff there exists $[[ii]]$ such that $[[e -->> ii]]$ and
%   $[[e' -->> ii]]$.
% \end{definition}

\begin{definition}[\fnamee Contextual Equivalence]
  \begin{align*}
    &[[DD ; GG |- ee1 ~= ee2 : A]]  \defeq \forall [[e1]], [[e2]].\  [[DD ; GG |- ee1 => A ~~> e1]] \land [[DD ; GG |- ee2 => A ~~> e2]] \ \land   \\
    &\qquad (\forall [[C]], [[cc]].\ [[CC : (DD; GG => A) ~> (empty ; empty => int) ~~> cc]] \Longrightarrow \kleq{[[cc{e1}]]}{[[cc{e2}]]})
  \end{align*}
\end{definition}


\paragraph{Coherence.}

We directly show the coherence statement of \fnamee.
We need several technical lemmas such as compatibility lemmas, fundamental property, etc.
The interested reader can refer to our Coq formalization.

\begin{theorem}[\href{https://github.com/bixuanzju/phd-thesis-artifact/blob/master/coq/poly/Coherence.v\#L363}{\leftpointright} Coherence of \fnamee] \label{thm:coherence:fi} % APPLYCOQ=COHERENCE
  We have that
  \begin{itemize}
  \item If $[[DD ; GG |- ee => A ]]$ then $[[DD ; GG |- ee ~= ee : A]]$.
  \item If $[[DD ; GG |- ee <= A ]]$ then $[[DD ; GG |- ee ~= ee : A]]$.
  \end{itemize}
\end{theorem}
% \noindent That is, coherence is a special case of \cref{def:cxtx2} where
% $[[ee1]]$ and $[[ee2]]$ are the same. At first glance, this
% appears underwhelming: of course $[[ee]]$ behaves the same as itself! The tricky
% part is that, if we expand it according to \cref{def:cxtx2}, it is not $[[ee]]$
% itself but all its translations $[[e1]]$ and $[[e2]]$ that behave the same!

% Local Variables:
% TeX-master: "../../Thesis"
% org-ref-default-bibliography: "../../Thesis.bib"
% End: