
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% \begin{center}
%   \begin{minipage}{0.5\textwidth}
%     \begin{small}
%       In which the reasons for creating this package are laid bare for the
%       whole world to see and we encounter some usage guidelines.
%     \end{small}
%   \end{minipage}
%   \vspace{0.5cm}
% \end{center}


This thesis investigates the use of disjoint intersection types, a variant of
intersection types, focusing on its theoretical foundation and applications in
the context of Object-Oriented Programming. The results are three new typed
calculi, the first two being core calculi and the last one a source calculus,
combining the power of parametric polymorphism, a rich subtyping relation with
the fine-grained expressiveness of disjoint intersection types. The key
contribution of the thesis is that it unifies ideas that are seemingly unrelated
but powerful on their own in software engineering (nested composition, dynamic
inheritance, mixins, traits, extensible designs) by a single underlying
mechanism.


\section{Motivation}



\section{(Disjoint) Intersection Types}

A central theme of this thesis is \textit{intersection types} (usually written $\inter{A}{B}$). Intersection
types~\citep{pottinger1980type, coppoInter} have a long history in
programming languages. They were originally introduced to characterize exactly
all strongly normalizing lambda terms. Since then, starting with
\citeauthor{reynolds1988preliminary}'s work on
Forsythe~\citep{reynolds1988preliminary}, they have also been employed to
express useful programming language constructs, such as key aspects of
\emph{multiple inheritance}~\citep{compagnoni1996higher} in Object-Oriented
Programming (OOP). One notable example is the Scala
language~\citep{odersky2004overview} and its DOT
calculus~\citep{amin2012dependent}, which make fundamental use of intersection
types to express a class/trait that extends multiple other traits. Other modern
languages, such as TypeScript~\citep{typescript}, Flow~\citep{flow} and
Ceylon~\citep{ceylon}, also adopt some form of intersection types.

Intersection types come in different varieties in the literature. Some calculi
provide an \emph{explicit} introduction form for intersections, called the
\emph{merge operator}. This operator was introduced by \citeauthor{reynolds1988preliminary} in Forsythe~\citep{reynolds1988preliminary} and
adopted by a few other calculi~\citep{Castagna_1992, dunfield2014elaborating, oliveira2016disjoint, alpuimdisjoint}. Unfortunately,
while the merge operator is powerful, it also makes it hard to get a \emph{coherent}
(or unambiguous) semantics.
%A semantics is said to be coherent if all valid programs have the
%same meaning.\tom{The previous sentence is easily misunderstood.}
Unrestricted uses of the merge operator can be ambiguous, leading to an incoherent semantics
where the same program can evaluate to different values.
%Perhaps because of this
%issue the merge operator has not been adopted by many language designs.
We shall come back to this form of intersection types in more details in
\cref{bg:sec:intersection}.

A far more common form of intersection types are the so-called \emph{refinement
  types}~\citep{Freeman_1991, Davies_2000, dunfield2003type}. Refinement types
restrict the formation of intersection types so that the two types in an
intersection are refinements of the same simple (unrefined) type. For example,
we can refine a type $\mathsf{Int}$ of integers with a subtype $\mathsf{Odd}$ of
odd numbers, then an integer $1$ can be typed as follows:
\[
  1 : \inter{\mathsf{Int}}{\mathsf{Odd}}
\]
which satisfies the restriction: both $\mathsf{Int}$ and $\mathsf{Odd}$ refine a
single simple type $\mathsf{Int}$. Refinement intersection increases only the
expressiveness of types (more precise properties can be checked) and not of
terms. For this reason, \citet{dunfield2014elaborating} argues that refinement
intersection is unsuited for encoding various useful language features that
require the merge operator (or an equivalent term-level operator).


Recently, \citet{oliveira2016disjoint} proposed \oname: a calculus with a variant of intersection types
called \emph{disjoint intersection types}.
Calculi with disjoint intersection types feature the merge
operator, with restrictions that all expressions in a merge
operator must have disjoint types and all well-formed intersections
are also disjoint. A bidirectional type system and the disjointness restrictions
ensure that the semantics of the resulting calculi remains
coherent.

Disjoint intersection types have great potential to serve as a foundation for
powerful, flexible and yet type-safe OO languages that are easy to reason about.
As shown by \citet{alpuimdisjoint}, calculi with disjoint intersection types are
very expressive and can be used to statically type-check JavaScript-style
programs using mixins. Yet they retain both type safety and coherence. While
coherence may seem at first of mostly theoretical relevance, it turns out to be
very relevant for OOP. Multiple inheritance is renowned for being tricky to get
right, largely because of the possible \emph{ambiguity} issues caused by the
same field/method names inherited from different parents~\citep{bracha1990mixin,
  scharli2003traits}. Disjoint intersection types enforce that the types of
parents are disjoint and thus that no conflicts exist. Any violations are
statically detected and can be manually resolved by the programmer (for example
by dropping one of the conflicting field/methods from one of the parents). This
is very similar to existing trait models~\citep{scharli2003traits,
  Ducasse_2006}. Therefore in an OO language modelled on top of disjoint
intersection types, coherence implies that no ambiguity arises from multiple
inheritance. This makes reasoning a lot simpler. As we will see, this thesis
realizes this vision by proposing a powerful OO language design that builds on
the idea of disjoint intersection types.

\section{Family Polymorphism}

One powerful and long-standing idea in OOP is \emph{family
  polymorphism}~\citep{Ernst_2001}. In family polymorphism inheritance is
extended to work on a \emph{whole family of classes}, rather than just a single
class. This enables high degrees of modularity and code reuse, enabling simple
solutions to hard programming language problems, like the Expression
Problem~\citep{wadler1998expression}. An essential feature of family
polymorphism is \emph{nested composition}~\citep{Corradi_2012, ErnstVirtual,
  Nystrom_2004}, which allows the automatic inheritance/composition of nested
(or inner) classes when the enclosing classes are composed. Designing a sound
type system that fully supports family polymorphism and nested composition is
notoriously hard; there are only a few, quite sophisticated, languages that
manage this~\citep{ErnstVirtual, Nystrom_2004, pubsdoc:tribe-virtual-calculus,
  SAITO_2007}. This thesis shows that the combination of the merge operator and
a rich subtyping relation captures the essence of nested composition.

%To make matters worse, combining
%multiple inheritance with family polymorphism requires dealing with the various
%issues of both ideas.


\section{First-Class Classes, Mixins and Traits}

Many dynamically-typed languages (including JavaScript, Ruby, Python or Racket)
support \emph{first-class classes}. In those languages classes are first-class
values and, like any other values, they can be passed as an argument, or
returned from a function. Furthermore first-class classes support \emph{dynamic
  inheritance}: i.e., they can inherit from other classes at \emph{run time},
enabling programmers to abstract over the inheritance hierarchy. For example,
mixins~\citep{bracha1990mixin} become programmer-defined constructs -- a mixin is
simply a function that takes a class as an argument and returns a subclass. In
contrast, type system limitations prevent most statically-typed languages from
having first-class classes and dynamic inheritance.

Traits~\citep{scharli2003traits, Ducasse_2006} are an alternative to mixins, and
other models of (multiple) inheritance. The key difference between traits and
mixins lies on the treatment of conflicts when composing multiple traits/mixins.
Mixins adopt an \emph{implicit} resolution strategy for conflicts, where the
compiler automatically picks one implementation in case of conflicts. For
example, Scala uses the order of mixin composition to determine which
implementation to pick in case of conflicts. Traits, on the other hand, employ
an \emph{explicit} resolution strategy, where the compositions with conflicts
are rejected, and the conflicts are explicitly resolved by programmers.
\citet{scharli2003traits} make a good case for the advantages of the trait
model. In particular, traits avoid bugs that could arise from accidental
conflicts that were not noticed by programmers. With the mixin model, such
conflicts would be silently resolved, possibly resulting in unexpected run-time
behaviour due to a wrong method implementation choice. In a setting with dynamic
inheritance and first-class classes this problem is exacerbated by not knowing
all components being composed statically, greatly increasing the possibility of
accidental conflicts. From a modularity point-of-view, the trait model also
ensures that composition is \emph{commutative}, thus the order of composition is
irrelevant and does not affect the semantics. \citet{bracha1992programming}
claims that ``\emph{The only modular solution is to treat the name collisions as
  errors...}'', strengthening the case for the use of a trait model of
composition. Otherwise, if the semantics is affected by the order of
composition, global knowledge about the full inheritance graph is required to
determine which implementations are chosen. % \citet{scharli2003traits} discuss
% several other issues with mixins, which can be improved by traits. We refer to
% their paper for further details.
This thesis shows that with the merge operator
and disjoint intersection types, we are able to encode typed first-class traits.
Combined with the power of parametric polymorphism, we can further encode a very
dynamic form of mixin-style compositions, enabling highly modular designs with
Object Algebras~\citep{oliveira2012extensibility}.


\section{Contributions}

In this thesis, we present three new typed calculi, each building on top of the previous one.

\paragraph{The \namee Calculus.}

The first one named \namee is a simple calculus with records and disjoint
intersection types that supports \emph{nested composition}. The essential
novelty of \namee are distributivity rules between function/record types and
intersection types. These rules are the delta that enable extending the simple
forms of multiple inheritance/composition supported by \oname into a more
powerful form supporting nested composition. The key difficulty of adding
distributivity rules to a type system with disjoint intersection types is how to
preserve coherence. Although previous work on disjoint intersection types
proposes a solution to coherence, the solution imposes several ad-hoc
restrictions to guarantee the uniqueness of the elaboration and thus allow for a
simple syntactic proof of coherence. However such restrictions makes it hard or
impossible to adapt the proof to extensions of the calculus with distributivity
rules. To deal with coherence, we employ a more semantic proof method based on
\emph{logical relations}~\citep{tait, plotkin1973lambda, statman1985logical}.
Using the new proof method, we removed those restrictions and successfully
mechanized the coherence proof for \namee.

\paragraph{The \fnamee Calculus.}

The second one named \fnamee is a polymorphic calculus with disjoint
intersection types. \fnamee is essentially \namee enriched with a variant of
parametric polymorphic called disjoint polymorphism~\citep{alpuimdisjoint}. The
addition of parametric polymorphic increases the expressiveness power of \namee
dramatically, \fnamee is able to encode a very dynamic form of mixin-style
compositions. The first difficulty of adding parametric polymorphism is that
when a type variable occurs in an intersection type, it is not statically known
whether the instantiated type will be disjoint to other components of the
intersection (which may as well be type variables). The second difficulty is how
to prove coherence in the polymorphic setting. To address the first, \citet{alpuimdisjoint}
proposed \textit{disjointness constraint}, inspired by bounded
quantification~\citep{cardelli1994extension}, where type variables are constrained so that they are disjoint
to some given types. To address the second, we adapt the parametric logical
relation of System F to deal with disjoint polymorphism.



\paragraph{Typed First-Class Traits.}

Lastly we present the design of \sedel: a polymorphic (source) language with
\emph{first-class traits}, supporting \emph{dynamic inheritance} as well as
conventional OO features such as \emph{dynamic dispatching} and \emph{abstract
  methods}. Traits pose additional challenges when compared to models with
first-class classes or mixins, because method conflicts should be detected
\emph{statically}, even in the presence of features such as dynamic inheritance and
parametric polymorphism. To address the challenges of
typing first-class traits and detecting conflicts statically, \sedel adopts the
well-established approach of elaborating high-level language constructs to a
low-level core calculus. The main contribution of \sedel is to show how to model
source language constructs for first-class traits and dynamic inheritance. The
work on \namee and \fnamee aimed at core record calculi, and omits important
features for practical OO languages, including (dynamic) inheritance, dynamic
dispatching and abstract methods. Based on \citeauthor{cook1989denotational}'s
work on the denotational semantics for inheritance~\citep{cook1989denotational},
we show how to design a source language that is elaborated into \fnamee.
\sedel's elaboration into \fnamee is proved to be both type-safe and coherent.
Coherence ensures that the semantics of \sedel is unambiguous. In particular
this property is useful to ensure that programs using traits are free of
conflicts/ambiguities (even when the types of the object parts being composed
are not fully statically know). We illustrate the applicability of \sedel with
several example uses for first-class traits. Furthermore we conduct a case study
that modularizes programming language interpreters using a highly modular form
of \visitor.

In summary the contributions of this theis are:

\begin{itemize}

\item We present \namee, a calculus with disjoint intersection types that
  features both \emph{BCD-style subtyping} and \emph{the merge operator}. This
  calculus is both type-safe and coherent, and supports \emph{nested composition}.

\item We present \fnamee, a polymorphic calculus with disjoint intersection
  types. We show how \fnamee is able to provide basic support for dynamic mixins
  and basic operations of extensible records. \fnamee is both type-safe and
  coherent.

\item We present \sedel, a statically-typed language design that supports
  first-class traits, dynamic inheritance, as well as standard OO features such
  as dynamic dispatching and abstract methods. We show how the semantics of
  \sedel can be defined by elaboration into \fnamee.

\item A more flexible notion of disjoint intersection types where only merges
  need to be checked for disjointness. This removes the need for enforcing
  disjointness for all well-formed types, making type systems with disjoint
  intersections more easily extensible.

\item A more powerful proof strategy for coherence of type systems with disjoint
  intersection types based on logical relations.


\item A comprehensive Coq mechanization of all metatheory. This has notably
  revealed several missing lemmas and oversights in Pierce's manual
  proof of BCD's algorithmic subtyping~\citep{pierce1989decision}. As a
  by-product, we obtain the first mechanically verified BCD-style subtyping
  algorithm with coercions.

\item A full-blown implementation of \sedel; it runs and type-checks all the
  examples in this thesis.\footnote{The Coq formalization and implementation are
    available at \url{https://goo.gl/R5hUAp}.} We also conduct a case study,
  which shows that support for composition of Object
  Algebras~\citep{oliveira2012extensibility} is greatly
  improved in \sedel. Using such improved design patterns we re-code the
  interpreters from an undergraduate textbook on programming
  languages~\citep{poplcook} in a modular way.

\end{itemize}


% The author also contributed to the following publications that do not directly
% relate to the topics of this thesis:
% \begin{itemize}
% \item Ningning Xie, Xuan Bi, Bruno C. d. S. Oliveira. 2018. ``Consistent Subtyping for All''.
%   In \textit{European Symposium on Programming (ESOP)}.
% \item Yanpeng Yang, Xuan Bi, Bruno C. d. S. Oliveira. 2016. ``Unified Syntax with
%   Iso-Types''. In \textit{Asian Symposium on Programming Languages and
%     Systems (APLAS)}.
% \item Tomas Tauber, Xuan Bi, Zhiyuan Shi, Weixin Zhang, Huang Li, Zhenrui Zhang,
%   Bruno C. d. S. Oliveira. 2015. ``Memory-efficient Tail Calls in the JVM with
%   Imperative Functional Objects''. In \textit{Asian Symposium on
%     Programming Languages and Systems (APLAS)}.
% \end{itemize}


\section{Structure of the Thesis}

We begin with some background in the main topics of this thesis in
\cref{chap:background} in order to keep this thesis as self-contained as
possible and also to put our methods and contributions into context. The
structure of the technical content in the thesis is divided into three parts:
\begin{description}
\item[Part I:] \Cref{chap:nested,chap:fi} formally define the type systems of
  \namee and \fnamee, respectively. We first give the syntax and semantics of
  the two calculi. The semantics is defined in two parts. The ``target''
  languages are two standard type systems (simply-typed lambda calculus and
  System F, respectively) that do not have intersection types, the merge
  operator or subtyping. The ``source'' languages, defined by translation into
  the target languages, contain intersection types, the merge operator and
  subtyping. We then prove some basic properties such as type safety of
  the elaboration, soundness and completeness of the algorithmic subtyping, etc.
\item[Part II:] \Cref{chap:coherence:simple,chap:coherence:poly} explore the
  issue of coherence. In \cref{chap:coherence:simple} we first propose a
  semantically-founded definition of coherence. We then use a proof method based
  on logical relations to establish coherence of \namee. In
  \cref{chap:coherence:poly} we follow the same technique in
  \cref{chap:coherence:simple} but encounter a severe issue of impredicativity. We
  then adapt the parametric logical relation and establish coherence of \fnamee.
\item[Part III:] In \cref{chap:traits} we present the syntax and semantics of
  \sedel. In particular we show how to elaborate source-level constructs for
  first-class traits into expressions of \fnamee. In \cref{chap:case_study} we
  conduct a case study of modularizing programming language features using a
  highly modular form of \visitor.
\end{description}
Finally \cref{sec:related} reviews related work and \cref{chap:conclusion}
presents some future work and concludes.

This thesis is largely based on two publications by the author, which are shown
in the list below with corresponding chapters indicated. The work on \fnamee is
based on an on-going draft by the author (\cref{chap:fi,chap:coherence:poly}).
In comparison to the original publications, this thesis contains a more in-depth
and consistent treatment of disjoint intersection types.

\begin{description}
\item[\cref{chap:nested,chap:coherence:simple}:] Xuan Bi, Bruno C. d. S.
  Oliveira, and Tom Schrijvers. 2018. ``The Essence of Nested Composition''. In
  \textit{European Conference on Object-Oriented Programming (ECOOP)}.
\item[\cref{chap:traits,chap:case_study}:] Xuan Bi and Bruno C. d. S. Oliveira.
  2018. ``Typed First-Class Traits''. In \textit{European Conference on Object-Oriented Programming (ECOOP)}.
\end{description}

\noindent\makebox[\linewidth]{\rule{0.7\textwidth}{0.4pt}}

\vspace{1.5\baselineskip}

This thesis assumes familiarity with basic knowledge of programming languages
theory and object-oriented programming. We recommend
\citeauthor{DBLP:books/daglib/0005958}'s excellent textbook on programming
languages~\citep{DBLP:books/daglib/0005958} for a general introduction.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Thesis"
%%% org-ref-default-bibliography: ../Thesis.bib
%%% End:
