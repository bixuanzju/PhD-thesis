
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% \begin{center}
%   \begin{minipage}{0.5\textwidth}
%     \begin{small}
%       In which the reasons for creating this package are laid bare for the
%       whole world to see and we encounter some usage guidelines.
%     \end{small}
%   \end{minipage}
%   \vspace{0.5cm}
% \end{center}


This thesis investigates the use of disjoint intersection types, a variant of
intersection types, focusing on its theoretical foundation and applications to
Object-Oriented Programming in the presence of multiple inheritance. The results
are three new typed calculi, the first two being core calculi and the last one a
source calculus, combining the power of parametric polymorphism, a rich subtyping
relation with the fine-grained expressiveness of disjoint intersection types.


\section{(Disjoint) Intersection Types}


Intersection types~\citep{pottinger1980type,coppo1981functional} have a long
history in programming languages. They were originally introduced to
characterize exactly all strongly normalizing lambda terms. Since then, starting
with \citeauthor{reynolds1988preliminary}'s work on
Forsythe~\citep{reynolds1988preliminary}, they have also been employed to
express useful programming language constructs, such as key aspects of
\emph{multiple inheritance}~\citep{compagnoni1996higher} in Object-Oriented
Programming (OOP). One notable example is the Scala
language~\citep{odersky2004overview} and its DOT
calculus~\citep{amin2012dependent}, which make fundamental use of intersection
types to express a class/trait that extends multiple other traits. Other modern
languages, such as TypeScript~\citep{typescript}, Flow~\citep{flow} and
Ceylon~\citep{ceylon}, also adopt some form of intersection types.

Intersection types come in different varieties in the literature. Some calculi
provide an \emph{explicit} introduction form for intersections, called the
\emph{merge operator}. This operator was introduced by \citeauthor{reynolds1988preliminary} in Forsythe~\citep{reynolds1988preliminary} and
adopted by a few other calculi~\citep{Castagna_1992, dunfield2014elaborating, oliveira2016disjoint, alpuimdisjoint}. Unfortunately,
while the merge operator is powerful, it also makes it hard to get a \emph{coherent}
(or unambiguous) semantics.
%A semantics is said to be coherent if all valid programs have the
%same meaning.\tom{The previous sentence is easily misunderstood.}
Unrestricted uses of the merge operator can be ambiguous, leading to an incoherent semantics
where the same program can evaluate to different values.
%Perhaps because of this
%issue the merge operator has not been adopted by many language designs.
A far more common form of intersection types are the so-called \emph{refinement
  types}~\citep{Freeman_1991, Davies_2000, dunfield2003type}. Refinement types
restrict the formation of intersection types so that the two types in an
intersection are refinements of the same simple (unrefined) type. For example,
we can refine a type $\mathsf{Int}$ of integers with a subtype $\mathsf{Odd}$ of
odd numbers, then an integer $1$ can be typed as follows:
\[
  1 : \inter{\mathsf{Int}}{\mathsf{Odd}}
\]
which satisfies the restriction: both $\mathsf{Int}$ and $\mathsf{Odd}$ refine a
single simple type $\mathsf{Int}$. Refinement intersection increases only the
expressiveness of types and not of terms. For this reason,
\citet{dunfield2014elaborating} argues that refinement intersection is unsuited
for encoding various useful language features that require the merge operator
(or an equivalent term-level operator).


Recently, \citet{oliveira2016disjoint} proposed \oname: a calculus with a variant of intersection types
called \emph{disjoint intersection types}.
Calculi with disjoint intersection types feature the merge
operator, with restrictions that all expressions in a merge
operator must have disjoint types and all well-formed intersections
are also disjoint. A bidirectional type system and the disjointness restrictions
ensure that the semantics of the resulting calculi remains
coherent.

\begin{comment}
The merge operator was introduced by Reynolds
and Forsythe and adopted by a few other calculi as well~\citep{}.
Unfortunately, while the merge operator is powerful, it makes
it hard to get a \emph{coherent} semantics. \bruno{what is coherence}
Perhaps because
of this issue the merge operator has not been adopted by
many language designs. Disjoint intersection types provide
a remedy for the coherence problem, by imposing restrictions
on the uses of merges and on the formation of intersection types.
\bruno{merge operator ==> models inheritance; intersection types ==>
model subtyping}

In essence disjoint intersection types retain most of the
expressive power of the merge operator.
For example, they can
be used to model powerful forms of extensible records~\citep{}.
\end{comment}

Disjoint intersection types have great potential to serve as a foundation for
powerful, flexible and yet type-safe OO languages that are easy to reason
about. As shown by \citet{alpuimdisjoint}, calculi with disjoint intersection
types are very
expressive and can be used to statically type-check JavaScript-style programs
using mixins. Yet they retain both type safety and coherence. While
coherence may seem at first of mostly theoretical relevance, it
turns out to be very relevant for OOP. Multiple
inheritance is renowned for being tricky to get right, largely because of the
possible \emph{ambiguity} issues caused by the same field/method names
inherited from different parents~\citep{bracha1990mixin, scharli2003traits}. Disjoint intersection types
enforce that the types of parents are disjoint and thus that no conflicts exist.
Any violations are statically detected and can be manually resolved by the
programmer.
%(for example by dropping one
%of the conflicting field/methods from one of the parents).
This is very similar to existing trait models~\citep{scharli2003traits, Ducasse_2006}. Therefore in an OO language
modelled on top of disjoint intersection types, coherence implies
that no ambiguity arises from multiple inheritance. This makes
reasoning a lot simpler.

\section{Family Polymorphism}
One powerful and long-standing idea in OOP is \emph{family
  polymorphism}~\citep{Ernst_2001}. In family polymorphism inheritance is
extended to work on a \emph{whole family of classes}, rather than just a single
class. This enables high degrees of modularity and reuse, including simple
solutions to hard programming language problems, like the Expression
Problem~\citep{wadler1998expression}. An essential feature of family
polymorphism is \emph{nested composition}~\citep{Corradi_2012, ErnstVirtual,
  Nystrom_2004}, which allows the automatic inheritance/composition of nested
(or inner) classes when the enclosing classes are composed. Designing a sound
type system that fully supports family polymorphism and nested composition is
notoriously hard; there are only a few, quite sophisticated, languages that
manage this~\citep{ErnstVirtual, Nystrom_2004, pubsdoc:tribe-virtual-calculus,
  SAITO_2007}. This thesis shows that the combination of the merge operator and
a rich subtyping relation captures the essence of nested composition.

%To make matters worse, combining
%multiple inheritance with family polymorphism requires dealing with the various
%issues of both ideas.


\section{First-Class Classes, Mixins and Traits}

Many dynamically-typed languages (including JavaScript, Ruby, Python or Racket)
support \emph{first-class classes}, or related concepts such as first-class
traits and/or mixins. In those languages classes are first-class values and,
like any other values, they can be passed as an argument, or returned from a
function. Furthermore first-class classes support \emph{dynamic inheritance}:
i.e., they can inherit from other classes at \emph{runtime}, enabling programmers
to abstract over the inheritance hierarchy. In contrast, type system limitations
prevent most statically-typed languages from having first-class classes and
dynamic inheritance. Traits~\citep{scharli2003traits, Ducasse_2006} are an alternative to
mixins, and other models of (multiple) inheritance. The key difference between
traits and mixins lies on the treatment of conflicts when composing multiple
traits/mixins. Mixins adopt an \emph{implicit} resolution strategy for
conflicts, where the compiler automatically picks one implementation in case of
conflicts. For example, Scala uses the order of mixin composition to determine
which implementation to pick in case of conflicts. Traits, on the other hand,
employ an \emph{explicit} resolution strategy, where the compositions with
conflicts are rejected, and the conflicts are explicitly resolved by
programmers.

\citet{scharli2003traits} make a good case for the advantages of the trait
model. In particular, traits avoid bugs that could arise from accidental
conflicts that were not noticed by programmers. With the mixin model, such
conflicts would be silently resolved, possibly resulting in unexpected runtime
behaviour due to a wrong method implementation choice. In a setting with dynamic
inheritance and first-class classes this problem is exacerbated by not knowing
all components being composed statically, greatly increasing the possibility of
accidental conflicts. From a modularity point-of-view, the trait model also
ensures that composition is \emph{commutative}, thus the order of composition is
irrelevant and does not affect the semantics. \citet{bracha1992programming}
claims that ``\emph{The only modular solution is to treat the name collisions as
  errors...}'', strengthening the case for the use of a trait model of
composition. Otherwise, if the semantics is affected by the order of
composition, global knowledge about the full inheritance graph is required to
determine which implementations are chosen. \citet{scharli2003traits} discuss
several other issues with mixins, which can be improved by traits. We refer to
their paper for further details. This thesis shows that with the merge operator
and disjoint intersection types, we are able to encode typed first-class traits.
Combined with the power of parametric polymorphism, we can further encode a very
dynamic form of mixin-style compositions, enabling highly modular designs with
Object Algebras~\citep{oliveira2012extensibility}.


\section{Contributions}

In this thesis, we present three new typed calculi, each building on top of the previous one.

\paragraph{The \namee Calculus.}

The first one named \namee is a simple calculus with records and disjoint
intersection types that supports \emph{nested composition}. The essential
novelty of \namee are distributivity rules between function/record types and
intersection types. These rules are the delta that enable extending the simple
forms of multiple inheritance/composition supported by \oname into a more
powerful form supporting nested composition. The key difficulty of adding
distributivity rules to a type system with disjoint intersection types is how to
preserve coherence. Although previous work on disjoint intersection types
proposes a solution to coherence, the solution imposes several ad-hoc
restrictions to guarantee the uniqueness of the elaboration and thus allow for a
simple syntactic proof of coherence. However such restrictions makes it hard or
impossible to adapt the proof to extensions of the calculus with distributivity
rules. To deal with coherence, we employ a more semantic proof method based on
\emph{logical relations}~\citep{tait, plotkin1973lambda, statman1985logical}.
Using the new proof method, we removed those restrictions and successfully
mechanized the coherence proof for \namee.

\paragraph{The \fnamee Calculus.}

The second one named \fnamee is a polymorphic calculus with disjoint
intersection types. \fnamee is essentially \namee enriched with a variant of
parametric polymorphic called disjoint polymorphism~\citep{alpuimdisjoint}. The
addition of parametric polymorphic increases the expressiveness power of \namee
dramatically, \fnamee is able to encode a very dynamic form of mixin-style
compositions. The first difficulty of adding parametric polymorphism is that
when a type variable occurs in an intersection type, it is not statically known
whether the instantiated type will be disjoint to other components of the
intersection (which may as well be type variables). The second difficulty is how
to prove coherence in the polymorphic setting. To address the first, \citet{alpuimdisjoint}
proposed \textit{disjointness constraint}, inspired by bounded
quantification~\citep{cardelli1994extension}, where type variables are constrained so that they are disjoint
to some given types. To address the second, we adapt the parametric logical
relation of System F to deal with disjoint polymorphism.



\paragraph{Typed First-Class Traits.}

Lastly we present the design of \sedel: a polymorphic (source) language with
\emph{first-class traits}, supporting \emph{dynamic inheritance} as well as
conventional OO features such as \emph{dynamic dispatching} and \emph{abstract
  methods}. Traits pose additional challenges when compared to models with
first-class classes or mixins, because method conflicts should be detected
\emph{statically}, even in the presence of features such as dynamic inheritance
and composition and \emph{parametric polymorphism}. To address the challenges of
typing first-class traits and detecting conflicts statically, \sedel adopts the
well-established approach of elaborating high-level language constructs to a
low-level core calculus. The main contribution of \sedel is to show how to model
source language constructs for first-class traits and dynamic inheritance. The
work on \namee and \fnamee aimed at core record calculi, and omits important
features for practical OO languages, including (dynamic) inheritance, dynamic
dispatching and abstract methods. Based on \citeauthor{cook1989denotational}'s
work on the denotational semantics for inheritance~\citep{cook1989denotational},
we show how to design a source language that can be elaborated into \fnamee.
\sedel's elaboration into \fnamee is proved to be both type-safe and coherent.
Coherence ensures that the semantics of \sedel is unambiguous. In particular
this property is useful to ensure that programs using traits are free of
conflicts/ambiguities (even when the types of the object parts being composed
are not fully statically know). We illustrate the applicability of \sedel with
several example uses for first-class traits. Furthermore we conduct a case study
that modularizes programming language interpreters using a highly modular form
of visitors.

In summary the contributions of this theis are:

\begin{itemize}

\item We present \namee, a calculus with disjoint intersection types that
  features both \emph{BCD-style subtyping} and \emph{the merge operator}. This
  calculus is both type-safe and coherent, and supports \emph{nested composition}.

\item We present \fnamee, a polymorphic calculus with disjoint intersection
  types. We show how \fnamee is able to provide basic support for dynamic mixins
  and basic operations of extensible records. \fnamee is both type-safe and
  coherent.

\item We present \sedel, a statically-typed language design that supports
  first-class traits, dynamic inheritance, as well as standard OO features such
  as dynamic dispatching and abstract methods. We show how the semantics of
  \sedel can be defined by elaboration into \fnamee.

\item A more flexible notion of disjoint intersection types where only merges
  need to be checked for disjointness. This removes the need for enforcing
  disjointness for all well-formed types, making type systems with disjoint
  intersections more easily extensible.

\item A more powerful proof strategy for coherence of type systems with disjoint
  intersection types based on logical relations.


\item A comprehensive Coq mechanization of all meta-theory. This has notably
  revealed several missing lemmas and oversights in Pierce's manual
  proof of BCD's algorithmic subtyping~\citep{pierce1989decision}. As a
  by-product, we obtain the first mechanically verified BCD-style subtyping
  algorithm with coercions.

\item A full-blown implementation of \sedel; it runs and type-checks all the
  examples in this thesis.\footnote{The Coq formalization and implementation are
    available at \url{https://goo.gl/R5hUAp}.} We also conduct a case study,
  which shows that support for composition of Object
  Algebras~\citep{oliveira2012extensibility} and \textsc{Visitor}s is greatly
  improved in \sedel. Using such improved design patterns we re-code the
  interpreters from an undergraduate textbook on programming
  languages~\citep{poplcook} in a modular way.

\end{itemize}


This thesis is largely based on two publications by the author, which are
indicated in the list below. The work on \fnamee is based on an on-going draft
by the author. In comparison to the original publications, this thesis contains
a more in-depth and consistent treatment of disjoint intersection types.

\begin{itemize}
\item Xuan Bi, Bruno C. d. S. Oliveira, and Tom Schrijvers. 2018. ``The Essence
  of Nested Composition''. In \textit{European Conference on Object-Oriented Programming (ECOOP)}.
\item Xuan Bi and Bruno C. d. S. Oliveira. 2018. ``Typed First-Class Traits''.
  In \textit{European Conference on Object-Oriented Programming (ECOOP)}.
\end{itemize}


The author also contributed to the following publications that do not directly
relate to the topics of this thesis:
\begin{itemize}
\item Ningning Xie, Xuan Bi, Bruno C. d. S. Oliveira. 2018. ``Consistent Subtyping for All''.
  In \textit{European Symposium on Programming (ESOP)}.
\item Yanpeng Yang, Xuan Bi, Bruno C. d. S. Oliveira. 2016. ``Unified Syntax with
  Iso-Types''. In \textit{Asian Symposium on Programming Languages and
    Systems (APLAS)}.
\item Tomas Tauber, Xuan Bi, Zhiyuan Shi, Weixin Zhang, Huang Li, Zhenrui Zhang,
  Bruno C. d. S. Oliveira. 2015. ``Memory-efficient Tail Calls in the JVM with
  Imperative Functional Objects''. In \textit{Asian Symposium on
    Programming Languages and Systems (APLAS)}.
\end{itemize}


\section{Structure of the Thesis}

The structure of the thesis is organized as follows:

\begin{description}
\item[Part I:] \Cref{chap:nested,chap:fi} formally define the type systems of
  \namee and \fnamee, respectively. We first give the syntax and semantics of
  the two calculi. The semantics is defined in two parts. The ``target''
  languages are two standard type systems (simply-typed $\lambda$-calculus and
  System F, respectively) that do not have intersection types, the merge
  operator or subtyping. The ``source'' languages, defined by translation into
  the target languages, contain intersection types, the merge operator and
  subtyping. We then prove some basic properties such as type safety of
  the elaboration, soundness and completeness of the algorithmic subtyping, etc.
\item[Part II:] \Cref{chap:coherence:simple,chap:coherence:poly} explore the
  issue of coherence. In \cref{chap:coherence:simple} we first propose a
  semantically-founded definition of coherence. We then use a proof method based
  on logical relations to establish coherence of \namee. In
  \cref{chap:coherence:poly} we follow the same technique in
  \cref{chap:coherence:simple} but encounter a severe issue of impredicativity. We
  then adapt the parametric logical relation and establish coherence of \fnamee.
\item[Part III:] In \cref{chap:traits} we present the syntax and semantics of
  \sedel. In particular we show how to elaborate source-level constructs for
  first-class traits into expressions of \fnamee. In \cref{chap:case_study} we
  conduct a case study of modularizing programming language features using a
  highly modular form of visitors. Finally \cref{sec:related} reviews related
  work and \cref{chap:conclusion} presents some future work and concludes.
\end{description}

We begin with some background in the main topics of this thesis, to set the
stage for later chapters.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Thesis"
%%% org-ref-default-bibliography: ../Thesis.bib
%%% End:
