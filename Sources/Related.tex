
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related Work}
\label{sec:related}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


There is a great deal of work related to this thesis. We have touched some most
relevant work (notably intersection types) in \cref{chap:background}. In this
chapter, we briefly review other related work, starting with a summary of two
most common approaches on coherence (\cref{sec:related:coherence}). We then
consider various existing mechanisms to foster modularity and code reuse in the
rest of this chapter.


\section{Coherence}
\label{sec:related:coherence}

In calculi that feature coercive subtyping, a semantics that interprets the
subtyping judgment by introducing explicit coercions is typically defined on
typing derivations rather than on typing judgments. A natural question that
arises for such systems is whether the semantics is \textit{coherent}, i.e.,
distinct typing derivations of the same typing judgment possess the same
meaning. Since \citet{Reynolds_1991} proved the coherence of a calculus with
intersection types, based on the denotational semantics for intersection types,
many researchers have studied the problem of coherence in a variety of typed
calculi. Below we summarize two commonly-found approaches in the literature.

\subsection{Normalization-based Approach}
The first approach is based on normalization. \citet{Breazu_Tannen_1991} proved
the coherence of a coercion translation from
\textsf{Fun}~\citep{cardelli1985understanding} extended with recursive types to
System F by showing that any two typing derivations of the same judgment are
normalizable to a unique normal derivation where the correctness of the
normalization steps is justified by an equational theory in System F.
\citet{Curien_1992} presented a translation of System F$_\leq$ into a calculus
with explicit coercions and showed that any derivations of the same judgment are
translated to terms that are normalizable to a unique normal form. Following the
same approach, \citet{SCHWINGHAMMER_2008} proved the coherence of coercion
translation from Moggi's computational lambda calculus~\citep{Moggi_1991} with
subtyping.


\subsection{Context-based Approach}

Central to the first approach is to find a normal form for a representation of
the derivation and show that normal forms are unique for a given typing
judgment. However, this approach cannot be directly applied to Curry-style
calculi, i.e., where the lambda abstractions are not type annotated. Also this
line of reasoning cannot be used when the calculus has general recursion.
\citet{biernacki2015logical} considered the coherence problem of coercion
semantics. Their criterion for coherence of the translation is
\textit{contextual equivalence} in the target calculus. They presented a
construction of logical relations for establishing so constructed coherence for
coercion semantics, showing that this approach is applicable in a variety of
calculi, including delimited continuations and control-effect subtyping.

As far as we know, our work is the first to use logical relations to show the
coherence for intersection types and the merge operator. The BCD subtyping in
our setting poses a non-trivial complication over
\citeauthor{biernacki2015logical}'s simple structural subtyping. Indeed, because
any two coercions between given types are behaviorally equivalent in the target
language, their coherence reasoning can all take place in the target language.
This is not true in our setting, where coercions can be distinguished by
arbitrary target programs, but not those that are elaborations of source
programs. (Recall that $ \lambda \ottmv{x} .\, \pi_1 \, \ottmv{x} $ and $ \lambda \ottmv{x} .\, \pi_2 \, \ottmv{x} $ should be equated in our setting.)
Hence, we have to restrict our reasoning to the latter class, which is reflected
in a more complicated notion of contextual equivalence and our logical
relation's non-trivial treatment of pairs.

\section{Intersection Types and the Merge Operator}

Forsythe~\citep{reynolds1988preliminary} has intersection types and a merge-like
operator. However to ensure coherence, various restrictions were added to limit
the use of merges. Forsythe only permits $p_1 ,, p_2$ when $p_2$ is either an
lambda abstraction or a record, whose meaning ``overrides'' the corresponding
type of meaning of $p_1$. For instance, there is a rule regarding lambda
abstraction that says (adapted to our syntax):
\[
  \inferrule*{ \Gamma \vdash \lam{x}{p_2} : \theta_1 \rightarrow \theta_2  }{ \Gamma \vdash (p_1 ,, \lam{x}{p_2}) : \theta_1 \rightarrow \theta_2  }
\]
which means that in a merge of two functions, the second one always takes
precedence to the first one. In contrast, our typing rule for merges is more
fine-grained in the sense that both functions are retained as long as they are
disjoint. \citet{Castagna_1992} proposed a coherent calculus with a special
merge operator that works on functions only. Recently,
\citet{castagna2014polymorphic} studied a coherent calculus that has
polymorphism and set-theoretic type connectives (intersections, unions,
negations). Compared to \fnamee, their intersections are used between function
types, allowing overloading of types, e.g.,
\begin{lstlisting}[language=Haskell]
even :: (Int -> Bool) and ((a \ Int) -> (a \ Int))
even x = case x of
           | Int -> x `mod` 2 == 0
           | _   -> x
\end{lstlisting}
The weird-looking function operates differently according to
the type of the argument: it checks whether an argument is an integer; if it is
so it returns whether the integer is even or not, otherwise it returns the
argument as it received. Note that type difference (i.e., \lstinline{a \ Int}) is crucial to
ensure no ambiguity in the domain types of two functions. In \fnamee, we cannot
express this kind of intersections. However, \fnamee allows some other
intersections (e.g., $\inter{(\mathsf{Int} \rightarrow
  \mathsf{Bool})}{(\mathsf{Int} \rightarrow \mathsf{Int})}$) that are not
allowed in their system. Nevertheless, both systems need to express negative
information about type variables: in their system type difference (e.g.,
\lstinline{a \ Int}) achieves this, whereas in \fnamee we use disjointness
constraints (e.g., \lstinline{a * Int}).

\citet{dunfield2014elaborating} shows significant expressiveness
of type systems with (unrestricted) intersection types and a merge operator.
However his calculus lacks coherence. The limitation was addressed by
\citet{oliveira2016disjoint}, who introduced disjointness to ensure coherence.
The combination of intersection types, a merge operator and parametric
polymorphism, while achieving coherence was first studied in the \fname
calculus~\citep{alpuimdisjoint}. Compared to prior work, the approach in this
thesis simplifies type systems with disjoint intersection types by removing
several restrictions. Furthermore, our calculi adopt a more powerful subtyping
relation based on BCD subtyping, which in turn requires the use of a more
powerful logical relations based method for proving coherence. On a pragmatic
note, dynamic inheritance, self-references and abstract methods are all missing
from prior work, but, as shown in this thesis, they can be encoded using an
elaboration that employs ideas from the denotational model of
inheritance~\citep{cook1989denotational}.


% The combination of intersection types, a merge
% construct and parametric polymorphism, while achieving coherence was first
% studied in the \fname calculus~\citep{alpuimdisjoint}.
% % where they proposed the notion of disjoint polymorphism.
% \fname serves as the target language
% of \namee.
% \bruno{This is an example of a typical mistake when writting related
%   work: you describe existing work, but do not say how it
%   relates/differs from the work presented in the paper.}


\section{Intersection Types and Multiple Inheritance}

\citet{compagnoni1996higher} added intersection types to
$\mathsf{F}_{<:}^{\omega}$, an extension of System $\mathsf{F}^{\omega}$ with
bounded quantification, and proposed a new calculus
$\mathsf{F}_{\land}^{\omega}$ to model multiple inheritance. In their system,
two types of the same kind $K$ can form an intersection. Recently, some form of
intersection types have been adopted in object-oriented languages such as Scala,
TypeScript, Flow, Ceylon, and Grace. The DOT
calculus~\citep{amin2012dependent,Rompf_2016}, a new type-theoretic foundation
for Scala, also incorporate intersection types. The most significant difference
between our calculi and those languages/calculi is that they do not have an
explicit introduction form of intersection types, like our merge operator. The
lack of a native merge operator leads to some awkward and type-unsafe solutions
for defining a merge operator in those languages. As noted by
\citet{alpuimdisjoint}, TypeScript's use of intersection types is the following
function:
\begin{lstlisting}[language=JavaScript]
function extend<T, U>(first: T, second : U) : T & U {...}
\end{lstlisting}
which is analogous to our merge operator that takes two objects and produces
an object with the intersection of the types of the argument objects. The
implementation of \lstinline{extend} relies on low-level (and type-unsafe)
features of JavaScript. Similar encodings have also been proposed for Scala to
enable applications where the merge operator plays a fundamental
role~\citep{oliveira2013feature, rendel14attributes}.

\section {BCD Type System and Decidability}

The BCD type system was first introduced by \citet{Barendregt_1983}. It is
derived from a filter lambda model in order to characterize exactly the strongly
normalizing terms. The BCD type system features a powerful subtyping relation,
which serves as a base for our subtyping relation.
\citet{DBLP:journals/corr/BessaiDDCd15} show how to type classes and mixins in
a BCD-style record calculus with a merge-like operator~\citep{bracha1990mixin}
that only operates on records, and they only study a type assignment system. The
decidability of BCD subtyping has been shown in several
works~\citep{pierce1989decision, Kurata_1995, Rehof_2011, Statman_2015}.
\citet{laurent2012intersection} formalized the relation in Coq in order to
eliminate transitivity cuts from it, but his formalization does not deliver an
algorithm. Based on \citeauthor{Statman_2015}'s work~\citep{Statman_2015},
\citet{bessaiextracting} present a formally verified subtyping algorithm in Coq.
Our Coq formalization follows a different idea based on Pierce's decision
procedure~\citep{pierce1989decision}, which is shown to be easily extensible to
coercions and records. In the course of our mechanization we identified several
mistakes in Pierce's proofs, as well as some important missing lemmas.

\section{Family Polymorphism}

There has been much work on family polymorphism since \citeauthor{Ernst_2001}'s
original proposal~\citep{Ernst_2001}. Family polymorphism provides an elegant
solution to the expression problem. Although a simple Scala solution does exist
without requiring family polymorphism (e.g., see \citet{wang2016expression}), Scala does not support nested composition:
programmers need to manually compose all the classes from multiple extensions.
Generally speaking, systems that support family polymorphism can be divided into
two categories: those that support \textit{object families} and those that
support \textit{class families}. The original object family approach of
\textsc{Beta }(e.g., virtual classes~\citep{Madsen_1989}) treats nested classes as
attributes of objects of the family classes, whereas in class families,
classes are nested in other classes. The former choice is considered more
expressive~\citep{ErnstVirtual}, but requires a complex type system usually
involving dependent types. The object and class family approaches have even been
combined by the work on Tribe~\citep{pubsdoc:tribe-virtual-calculus}.

\paragraph{Object Families.}

Virtual classes~\citep{Madsen_1989} as introduced in
\textsc{Beta}~\citep{LehrmannMadsen:1993:OPB:221048} are based on object
families. However, the virtual class mechanism in \textsc{Beta} is unsound.
Path-dependent types are used to ensure type safety for virtual types and
virtual classes in the calculus \textit{vc}~\citep{ErnstVirtual}. One distinct
difference from our calculi is that \textit{vc} follows the mixin-style by
allowing the rightmost class to take precedence, whereas in \namee conflicts are
detected statically and resolved explicitly.

\paragraph{Class Families.}

Concord~\citep{jolly2004simple}, Jx~\citep{Nystrom_2004} and
J\&~\citep{Nystrom:2006} follow the class family approach, where nested classes
and types are attributes of the family classes directly.
% Unlike virtual classes, subclass and subtype relationships are preserved by inheritance: the
% overriding class is also a subtype of the class it overrides.
%Nested inheritance
%does not support generic types. As we discussed in \cref{sec:diss}, \namee can be
%easily extended to incorporate parametric polymorphism.
Jx supports \textit{nested inheritance}, a class family mechanism that allows
nesting of arbitrary depth. J\& is a language that supports \textit{nested
  intersection}, building on top of Jx. Similar to our calculi, intersection
types play an important role in J\&, which are used to compose packages/classes.
However, J\& does not have a merge-like operator. When conflicts arise, prefix
types can be exploited to resolve the ambiguity. J\&$_s$~\citep{Qi:2009} is an
extension of the Java language that adds class sharing to J\&.
\citet{SAITO_2007} identified a minimal, lightweight set of language features to
enable family polymorphism,

Compared with those systems, which usually focus on getting a relatively complex
Java-like language with family polymorphism, our work on \namee focuses on a
minimal calculus that supports nested composition. We have shown that a calculus
with the merge operator and a variant of BCD subtyping captures the essence of nested
composition. Moreover \namee enables new insights on the subtyping relations of
families. Our goal in this thesis is not to support full family polymorphism
which, besides nested composition, also requires dealing with other features
such as self types~\citep{bruce95thistype,saito09matching} and mutable state.
But we expect to investigate those features in the future.


\section{Typed First-Class Classes/Mixins/Traits}

First-class classes have been used in Racket~\citep{DBLP:conf/aplas/FlattFF06},
along with mixin support, and have shown great practical value. For example,
DrRacket IDE~\citep{DBLP:journals/jfp/FindlerCFFKSF02} makes extensive use of
layered combinations of mixins to implement text editing features. The topic of
first-class classes with static typing has been explored by
\citet{DBLP:conf/oopsla/TakikawaSDTF12} in Typed Racket. They designed a gradual
type system that supports first-class classes. Of particular interest is their
use of row polymorphism~\citep{wand1994type} to type mixins. For example,
\lstinline{modal_mixin} from \cref{sec:trait:overview} implemented in Typed
Racket has type:
\begin{lstlisting}
(All (r / on-key toggle-mode)
     (Class ([on-key : (String -> Void)] | r)) ->
     (Class ([toggle-mode : (-> Void)] [on-key : (String -> Void)] | r)))
\end{lstlisting}
As with our use of disjoint polymorphism, row polymorphism can express
constraints on the presence or absence of members. Unlike disjoint polymorphism,
row polymorphism prohibits forgetting class members. While this is reasonable in
the setting of mixins, in some cases, a function taking one class as an argument
can return another class that has fewer methods. For example, in \sedel we can write:
\lstinputlisting[linerange=100-100]{./examples/overview2.sl}% APPLY:linerange=FOO
where \lstinline{foo} drops \lstinline{bar} from its argument trait
\lstinline{t}, which is impossible to express using row polymorphism. As a
consequence, Typed Racket ends up with two subtyping mechanisms: one for
first-class classes (via row polymorphism) and the other for objects (via normal
width subtyping). In contrast, \sedel uses only one mechanism---i.e., disjoint
polymorphism---to deal with both. Also as we pointed out in \cref{sec:merge},
row polymorphism alone cannot express the \lstinline{merge} function that is
able to compose objects of statically unknown types. In this sense, we argue
disjoint polymorphism is more powerful than row polymorphism in terms of
expressiveness. It would be interesting to investigate the relationship between
disjoint polymorphism and row polymorphism. We leave it as future work.


More recently, \citet{DBLP:conf/ecoop/LeeASP15} proposed a model for typed
first-class classes based on tagged objects. Like our development, the semantics
of their source language is defined by a translation into a target language. One
notable difference to \sedel is that they require the use of a variable rather
than an expression in the \lstinline{extends} clause, whereas we do not have
this restriction. In their source language, subclasses define subtypes, which
limits its applicability to extensible designs. Also their target calculus is
significantly more complex than ours due to the use of dependent function types
and dependent sum types. As they admitted, they omit inheritance in their
formalization.

Racket also supports a \emph{dynamically-typed model} of first-class
traits~\citep{DBLP:conf/aplas/FlattFF06}. However, unlike Racket's first-class
classes and mixins, there is no type system supporting the use of first-class
traits. A key difficulty is \emph{statically} detecting conflicts. In the mixin
model this is not a problem because conflicts are implicitly resolved using the
order of composition. As far as we know, \sedel is the first design for typed
first-class traits.


% There are multiple flavours of inheritance. To avoid confusion, since the same
% terminology is often used in the literature to mean different things, we use the
% following 3 terms when comparing related work with ours.

% \begin{itemize}
% \item{{\bf Static inheritance:}} Static inheritance refers to what the typical
%   model of inheritance in class-based languages. The inheritance model is said
%   to be static because when using class extension, the extended classes are
%   statically known at compile-time.
% \item{{\bf Mutable Inheritance:}} Prototype-based languages allow another model
%   of inheritance, which we call \emph{mutable inheritance}. In this inheritance
%   model, self-references are mutable and changeable at any point.
% \item{{\bf Dynamic Inheritance:}} Dynamic inheritance is a less well-known model
%   which stands in between static and mutable inheritance. Unlike the static
%   inheritance model, with dynamic inheritance objects can inherit from other
%   objects which are not statically known. However, unlike mutable inheritance,
%   the self-reference is not mutable and cannot be arbitrarily changed at
%   run-time.
% \end{itemize}

% \Cref{fig:comparision} shows the comparison between \namee and various
% similar languages that follow \cite{cook1989inheritance}'s ``Inheritance is not
% Subtyping'' (i.e. the flexible model), as we will explain below.

% \begin{figure}[t]
%   \centering
%   \begin{tabular}{|l||c|c|c|c|}
%     \hline
%     & \bf{Statically typed} & \bf{Polymorphism} & \bf{Meta-theory} & \bf{Inheritance}  \\
%     \hline
%     \namee & \cmark & \cmark & \cmark & Dynamic \\
%     \hline
%     \textsc{Self} & \xmark & \xmark & \xmark & Mutable \\
%     \hline
%     Cecil & \cmark & \cmark & \xmark & Static \\
%     \hline
%     Cook's Modula-3 & \cmark & \xmark & \xmark & Static \\
%     \hline
%     IFJ & \cmark & \xmark & \cmark & Dynamic \\
%     \hline
%     \textsc{Darwin} & \cmark & \xmark & \xmark & Dynamic \\
%     \hline
%   \end{tabular}
%   \caption{Comparison between \namee and various similar languages that
%   adopt the \emph{flexible model}.}
%   \label{fig:comparision}
% \end{figure}



% \paragraph{Dynamically-typed Languages with Delegation Mechanism}

% \begin{itemize}
% \item Clojure Protocols
%   % http://www.ibm.com/developerworks/library/j-clojure-protocols/
% \item Ruby mixin
% \item JS mixin
% \end{itemize}

% They are all dynamically typed.


% \paragraph{Delegation-based languages}

% \cite{lieberman1986using} is the first to promote the use of prototypes and
% delegation as the mechanism to code sharing between objects. Since then many
% researchers have studied the mechanisms of
% delegation~\citep{wegner1987dimensions,malenfant1995semantic,goldberg1989smalltalk}.

% There is not much work on statically-typed, delegation-based languages.
% \cite{kniesel1999type} provides a good overview of problems when combining
% delegation with a static type discipline. Cecil~\citep{chambers1992object,
%   chambers1993cecil} is a prototype-based language, where delegation is the
% mechanism for method call and code reuse. Cecil supports a polymorphic static
% type system, although no metatheory of any kind is given. Its type system is
% able to detect statically when a message might be ambiguously defined as a
% result of multiple inheritance or multiple dispatching. However, one major
% omission of Cecil, which is also one of the interesting features of \namee, is
% dynamic inheritance. There are other
% works~\citep{fisher1995delegation,anderson2003can} on delegation in a
% statically-typed setting, but none of them provide means (such as the merge
% construct, disjointness constraints, etc.) that are needed for extensible
% designs.

% \cite{cook1989inheritance} were the first to propose a typed model of
% inheritance where subtyping and inheritance are two separate concepts. In
% particular, they introduce the notion of \emph{type inheritance} and show that
% inherited objects have inherited types, not subtypes. An interesting aspect of
% their calculus is the \textbf{with} construct, used to join two records. This is
% somewhat similar to our merge construct. However two major differences are worth
% pointing out: 1) the \textbf{with} construct operates only on records; and 2) it
% is a biased operator, favoring values from its right argument. This biased
% operator is good for modelling mixins, but not traits. The
% \textbf{with} construct seems to be unable to merge two arbitrary (and possible
% polymorphic) values, since this seems to require something like
% \emph{row polymorphism}~\citep{wand1987complete,wand1989type}, which is not available in their language.
% The \emph{onion} construct in the Big Bang
% language~\citep{palmer2015building,menon2012big} has a similar bias problem -- it is a
% left-associative operator which gives rightmost precedence to one
% implementation when conflicts exist.

\section{Mixin-Based Inheritance}

\citeauthor{bracha1990mixin}'s seminal paper~\citep{bracha1990mixin} extends
Modula-3 with mixins. Since then, many mixin-based models have been
proposed~\citep{flatt1998classes,bono1999core, ancona2003jam}. Mixin-based
inheritance requires that mixins are composed linearly, and as such, conflicts
are resolved implicitly. In comparison, the trait model in \sedel requires
conflicts to be resolved explicitly. We want to emphasize that conflict
detection is essential in expressing composition operators for Object Algebras,
without running into ambiguities. \citeauthor{bracha1992programming}'s Jigsaw
framework~\citep{bracha1992programming} formalized mixin composition, along with
a rich trait algebra including merge, restrict, select, project, overriding and
rename operators. \citet{LAGORIO201286} proposed \textsc{FJig} that reformulates
Jigsaw constructs in a Java-like setting. \citet{DBLP:conf/oopsla/AllenBC03}
described how to add first-class generic types---including mixins---to OO
languages with nominal typing. \citet{Corradi_2012} described an extension of
\textsc{FJig} that integrates modular composition and nesting of Java-like
classes. It features a set of composition operators that allow to manipulate
nested classes at any depth level. In all of these systems, classes and mixins,
though they enjoy static typing, are still second-class constructs, and thus
their systems cannot express dynamic inheritance.


\section{Trait-Based Inheritance}

Traits were originally proposed by \citet{scharli2003traits}, and later formalized by ~\cite{Ducasse_2006} as a mechanism
for fine-grained code reuse to overcome many limitations of class-based
inheritance. The original proposal of traits were implemented in the
dynamically-typed class-based language \textsc{Squeak/Smalltalk}. Since then
various formalizations of traits in a Java-like (statically-typed) setting have
been proposed~\citep{fisher2004typed,scharli2003traitsformal,chai_trait,
  JOT:issue_2006_05/article4}. In most of the above proposals, trait composition
complements class-based inheritance. \sedel, in the spirit of \textit{pure trait-based programming languages}~\citep{BETTINI2013521, BETTINI2017419},
embraces traits as the sole mechanism for code reuse. The deviation from
traditional class-based inheritance is not only because of its simplicity, but
also because we need a very \emph{dynamic} form of inheritance. In comparison to
the traditional trait mode, traits in \sedel have the following differences:
\begin{enumerate}
\item traditional traits cannot be instantiated but only composed with a class,
  whereas traits in \sedel can be instantiated directly;
\item traditional traits cannot take constructor parameters whereas ours can;
\item the trait system in \sedel lacks a proper notion of inheritance
  relationship, e.g., in the traditional trait model, if the \textit{same}
  method is obtained more than once via different paths, there is no conflict.
  This is not the case in \sedel;
\item and finally traits in \sedel are first-class and support dynamic
  inheritance.
\end{enumerate}



% \cite{flatt1998classes} proposed MIXEDJAVA, an extension to a subset of
% sequential Java called CLASSICJAVA with mixins. In their model, mixins
% completely subsume the role of classes (classes are mixins that do not inherit
% any services). One interesting aspect in their system is that two identically
% named methods are allowed to coexist, and are resolved at run-time with run-time
% context information provided by the current \emph{view} of an object. In
% comparison, conflicts in \namee are detected statically, and resolved by the
% programmers. Like \namee, their model also enforces the distinction between
% implementation inheritance and subtyping.

% \cite{bono1999core} develop an imperative class-based calculus that provides a
% formal model for both single and mixin inheritance. Objects are represented by
% records and produced by instantiating classes. In their calculus, the class
% construct is extensible but not subtypable, while objects are subtypable but not
% extensible. Like \namee, their system has a clean separation between subtyping
% and inheritance. Also, their type system does not have polymorphism.

% \cite{ancona2003jam} extends the Java language to support mixins, called Jam.
% Since Jam is an upward-compatible extension of Java 1.0, it is inheritantly a
% covariant mode. Unlike MIXEDJAVA, mixins can be only instantiated on classes,
% and there is no notion of mixin composition.


% Incomplete Featherweight Java (IFJ), proposed by \cite{bettini2008type}, is a
% conservative extension of Featherweight Java with incomplete objects. Besides
% standard classes, programmers can also define incomplete classes, whose
% instances are incomplete objects. Incomplete objects can be composed (by object
% composition) with complete objects, yielding new complete objects at run-time,
% while ensuring statically that the composition is type-safe. Incomplete objects
% are quite flexible, and support dynamic inheritance. However, object composition
% in IFJ is quite restrictive, compared to \namee, in that it can only compose an
% incomplete object with a complete object. In that regard, and also because IFJ's
% type system is not polymorphic, IFJ is unable to encode composition operators of
% Object Algebras. \cite{kniesel1999type} showed that type-safe integration of
% delegation with subtyping into a class-based model is possible, resulting in the
% \textsc{Darwin} model. In \textsc{Darwin}, the type of the parent object must be
% a declared class and this limits the flexibility of dynamic composition.
% Ostermann's delegation layers~\citep{ostermann2002dynamically} use delegation for
% doing dynamic composition in a system with virtual classes. This is in contrast
% with most other approaches that use class-based composition, but closer to the
% dynamic composition that we use in \namee.

\section{Languages with More Advanced Forms of Inheritance}

\textsc{Self}~\citep{ungar1988self} is a dynamically-typed, prototype-based
language with a simple and uniform object model. \textsc{Self}'s inheritance
model is typical of what we call \textit{mutable inheritance}, because an
object's parent slot may be assigned new values at run time. Mutable inheritance
is rather unstructured, and oftentimes access to any clashing methods will
generate a ``messageAmbiguous'' error at run time. Although \sedel's dynamic
inheritance is not as powerful as mutable inheritance, its static type system
can guarantee that no such errors occur at run time.
Eiffel~\citep{meyer1987eiffel} supports a sophisticated class-based multiple
inheritance with deep renaming, exclusion and repeated inheritance. Of
particular interest is that in Eiffel, name collisions are considered
programming errors, and ambiguities must be resolved explicitly by the
programmer (by means of renaming). In this regard, \sedel is quite like Eiffel.
However, the type system in \sedel is more lenient in that two identically named
methods with different signatures can coexist.
Grace~\citep{DBLP:journals/jot/NobleBBHJ17, DBLP:conf/ecoop/0002HNB16} is an
object-based language designed for education, where objects are created by
\textit{object constructors}.
% In that regard, Grace is similar to \namee in that
% both are not class-based.
Since Grace has mutable fields, it has to consider
many concerns when it comes to inheritance, resulting in a rather complex
inheritance mechanism with various restrictions.
% For example, Grace imposes the
% constraint that the object being inherited must be \emph{fresh}. The effect of
% the freshness constraint is that the expression in the inherit clause must
% generate a new object. As a consequence, the expression after
% \lstinline{inherit} could not be a variable, which seems to preclude
% dynamic inheritance.
Since \sedel is pure, a relatively simple
% delegation-based
encoding of traits with late binding of \lstinline{self}
suffices for our applications. Grace's support for multiple inheritance is
based on what they call \emph{instantiable traits}.
% Still the freshness constraint applies.
We believe that there is plenty to be learned from Grace's design of traits if
we want to extend our trait model with features such as mutable state.
\textsc{MetaFJig}~\citep{SERVETTO2014219} (an extension of \textsc{FJig})
supports \textit{dynamic trait replacement}~\citep{chai_trait, BETTINI2013907,
  Ducasse_2006}, a feature for changing the behavior of an object at run time by
replacing one trait for another. More recently, a Java-like language called
Familia~\citep{Zhang_2017} were proposed to combine subtyping polymorphism,
parametric polymorphism and family polymorphism.


% There are many other class-based OO languages that are equipped with more
% advanced forms of
% inheritance~\citep{meyer1987eiffel,buchi2000generic,ostermann2001object}. Most of
% them are heavyweight and are specific to classes. \namee is object-centered, more
% lightweight, and is dedicated to express extensible designs in a simpler way.



% \cite{kniesel1999type} is the first to show that type-safe integration of
% delegation with subtyping into a class-based model is possible, resulting in the
% DARWIN model. In the DARWIN model, the type of the parent object must be a
% declared class and this limits the flexibility of dynamic composition, whereas
% in \namee, the merge operator can merge/compose any objects. Another difference
% with \namee lies in the conflict resolution, where DARWIN relies on method
% overriding with the assumption that the author of the overriding method is aware
% of the effect.

% Generic wrappers~\citep{buchi2000generic} supports aggregating objects at
% run-time. In their model, once a ``wrappee'' is assigned to a ``wrapper'', the
% wrappee is fixed. GBETA~\citep{ernst2000gbeta} has some dynamic features that are
% related to delegation. Like Generic wrappers, parents in GBETA are fixed at
% run-time.

% \cite{ostermann2001object} proposed compound references (CR) as a abstraction
% for object references, which provides explicit linguistic support for combining
% different composition properties on-demand. The model is statically typed, and
% decouples subtype declaration from implementation reuse.


% \cite{ostermann2002dynamically} proposed delegation layers as an approach to
% decompose a collaboration into layers and compose these layers dynamically at
% run-time. This combines and generalizes delegation and virtual classes concepts.

% \cite{ostermann2008nominal} compared the nominal and structural subtyping
% mechanisms. They argue nominal subtyping gives more safety guarantee, whereas
% structural subtyping is more flexible from a component-based perspective. The
% type system of \namee chooses structural subtyping.

\section{Module Systems}

In parallel to OOP, the ML module system originally proposed by
\citet{MacQueen_1984} also offers powerful support for flexible program
construction, data abstraction and code reuse. Mixin modules in the Jigsaw
framework~\citep{Bracha92modularitymeets} provides a suite of operators for
adapting and combining modules. The MixML~\citep{Rossberg_2013} module system
incorporates mixin module composition, while retaining the full expressive
powerful of ML modules. Module systems usually put more emphasis on supporting
type abstraction. Support for type abstraction adds considerable complexity,
which is not needed in \sedel. \sedel is focused on OOP and supports, among
others, method overriding, self references and dynamic dispatching, which
(generally speaking) are all missing features in module systems.
% One similarity between MixML and SEDEL is that
% both use an elaboration approach into a System F-like calculus.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Thesis"
%%% org-ref-default-bibliography: ../Thesis.bib
%%% End:
