
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Semantics of the \namee Calculus}
\label{chap:nested}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter presents \namee,\footnote{It was also called \name in the original
  publication~\citep{bi_et_al:LIPIcs:2018:9227}. Also the ``+'' symbol stands
  for two extra features compared to \oname: \emph{BCD subtyping} and
  \emph{unrestricted intersections}.} a calculus based on
\oname~\citep{oliveira2016disjoint} that
features unrestricted intersections, BCD-style subtyping and a merge operator, which we believe
captures the essence of nested composition. We illustrate this by presenting a
solution to the expression problem based on family polymorphism. We then discuss
the algorithmic aspects of \namee. The coherence property of \namee is discussed
in \cref{chap:coherence:simple}.

\section{Introduction}

\namee is a simple calculus with records and disjoint intersection types that
supports \emph{nested composition}. Nested composition enables encoding simple
forms of family polymorphism. More complex forms of family polymorphism,
involving binary methods~\citep{bruce1995binary} and mutable state are not yet
supported, but are interesting avenues for future work. Nevertheless, in \namee,
it is possible, for example, to encode \citeauthor{ernst2004expression}'s elegant family-polymorphism
solution to the expression problem. Compared to \oname the essential novelty of
\namee are distributivity rules between function/record types and intersection
types. These rules are the delta that enables extending the simple forms of
multiple inheritance/composition supported by \oname into a more powerful form
supporting nested composition. The distributivity rule between function types
and intersections is common in calculi with intersection types aimed at
capturing the set of all strongly normalizable terms, and was first proposed by
\citet{Barendregt_1983} (BCD). However the distributivity rule is not common in
calculi or languages with intersection types aimed at programming. For example
the rules employed in languages that support intersection types (such as Scala,
TypeScript, Flow or Ceylon) lack distributivity rules. Moreover distributivity
is also missing from several calculi with a merge operator. This includes all
calculi with disjoint intersection types~\citep{oliveira2016disjoint, alpuimdisjoint}
and \citeauthor{dunfield2014elaborating}'s work on elaborating
intersection types~\citep{dunfield2014elaborating}, which was the original
foundation for \oname. A possible reason for this omission in the past is that
distributivity adds substantial complexity (both algorithmically and
meta-theoretically), without having any obvious practical applications. This
chapter shows how to deal with the complications of BCD subtyping, while
identifying a major reason to include it in a programming language: BCD enables
nested composition and subtyping, which is of significant practical interest.

%The distributivity rules for records are
%new. Moreover, as far as we know, no previous work
%establishes the relation between BCD-style subtyping and nested composition.

\namee differs significantly from previous BCD-based calculi in that it has to
deal with the possibility of incoherence, introduced by the merge operator. Incoherence
is a non-issue in the previous BCD-based calculi because they do not feature
this merge operator or any other source of incoherence.
Although previous work on disjoint intersection types
proposes a solution to coherence, the solution imposes several ad-hoc restrictions (cf. \cref{sec:comparision})
to guarantee the uniqueness of the elaboration and thus allows for a simple
syntactic proof of coherence. Most
importantly, it makes it hard or impossible to adapt the proof to extensions of
the calculus, such as the new subtyping rules required by the BCD system.
We shall return to this point in
\cref{chap:coherence:simple}.


\input{Sources/Nested/overview.tex}
\input{Gen/Nested/typesystem.tex}
\input{Gen/Nested/algorithm.tex}
% \input{Sources/Nested/conclusion.tex}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Thesis"
%%% org-ref-default-bibliography: ../Thesis.bib
%%% End:
